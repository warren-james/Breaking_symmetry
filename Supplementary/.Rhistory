# setup some parameters
r <- seq(0.5, 3.5,.5)#seq(1,3,.5)
X <- seq(0.1, .9, 0.1)
n <- 28
df_pop <- tibble(n = numeric(),
r = numeric(),
init_pop = numeric(),
cur_pop = numeric())
for(R in r){
for(x in X){
init_pop <- x
for(ii in 0:n){
if(ii == 0){
cur_pop <- init_pop
} else {
cur_pop <- world_changer(R, cur_pop)
}
df_pop <- rbind(df_pop, tibble(n = ii,
r = R,
init_pop = init_pop,
cur_pop = cur_pop))
}
}
}
df_pop %>%
mutate(init_pop = as.factor(init_pop),
r = as.factor(r)) %>%
ggplot(aes(n, cur_pop,
colour = init_pop)) +
geom_point() +
geom_line() +
facet_wrap(~r)
r <- seq(0.5, 4, .01)
X <- .5
n <- 30
df_pop <- tibble(n = numeric(),
r = numeric(),
init_pop = numeric(),
cur_pop = numeric())
count <- 0
for(rate in r){
init_pop <- X
for(ii in 0:n){
if(ii == 0){
cur_pop <- init_pop
} else {
cur_pop <- world_changer(rate, cur_pop)
}
df_pop <- rbind(df_pop, tibble(n = ii,
r = rate,
init_pop = init_pop,
cur_pop = cur_pop))
}
count <- count + 1
print(paste(round((count/length(r))*100, digits = 3), "%", sep = ""))
}
df_pop %>%
mutate(R = as.factor(rate)) %>%
filter(n >20) %>%
ggplot(aes(r, cur_pop)) +
geom_point(size = .05,
colour = "white") +
# geom_line(aes(group = n),
#           size = .1,
#           colour = "white") +
see::theme_abyss()# + scale_x_continuous(limits = c(3.9,4))
install.packages("keras")
#### parabola stuff... ####
#### library ####
library(tidyverse)
#### functions ####
# This version has X and Y defined independently
# Which is how things would actually work....
parab_mk3 <- function(time, height, gravity, velocity, angle, wind){
if(missing(wind)){
wind <- 0
}
radians <- angle*pi/180
vel_x <- velocity * cos(radians)
vel_y <- velocity * sin(radians)
# horizontal distance
x <- (vel_x + wind) * time
# vertical distance
y <- height + vel_y * time - gravity * time^2/2
# output
output <- list(y = y, x = x)
return(output)
}
# need some other equations
# these equations help us figure out how much power is needed to reach a specified
# range given angle and effect of gravity
# find velocity needed for range X
find_vel <- function(range, angle, gravity){
radians <- angle*(pi/180)
vel <- sqrt(range/(sin(2*radians)/gravity))
return(vel)
}
# find range so we know where it should land?
find_range <- function(velocity, angle, gravity){
radians <- angle*(pi/180)
range <- velocity^2 * sin(2*radians)/gravity
return(range)
}
# sort out noise function
# this will take a velocity and decide how much noise there should be
add_noise <- function(velocity, power_range, scale, drop_point){
low <- power_range*drop_point
if(velocity <= low){
noise <- 0
} else {
# multiply by some constant... this can be tweaked to increase noise
# with distance...
noise <- ((velocity - low)/power_range)*scale
}
return(noise)
}
# above should be all the formulas we need to make the
# avatar perform the task
#### show results ####
# this part just draws some traces of various angles and powers to make sure that the functions
# work the way they were intended to... so no need to run this part if you trust my functions
# setup params
# t <- seq(0,10,.01)
# a <- 30# seq(15,75,15)
# g <- 10
# v <- seq(50,100,10)
# h <- 0
#
# # setup tibble
# temp <- tibble(time = rep(t, length(a) * length(v)),
#                angle = rep(a, each = length(v) * length(t)),
#                velocity = rep(rep(v, each = length(t)), length(a)),
#                gravity = g,
#                height = h,
#                y = parab_mk3(time, height, gravity, velocity, angle)$y,
#                x = parab_mk3(time, height, gravity, velocity, angle)$x)
#
# # plot this
# temp %>%
#   mutate(angle = as.factor(angle),
#          y = ifelse(y <= 0, 0, y)) %>%
#   ggplot(aes(x, y,
#              colour = angle)) +
#   # geom_point(alpha = .1) +
#   geom_line() +
#   scale_y_continuous(limits = c(0,1000)) +
#   facet_wrap(~velocity)
#### Simulating ####
# so this looks good now, the function works
# so let's simulate some trials
# to do this, we need to set some parameters so we can keep things constant
# and maybe allow participants to do something...
# we need to be able to specify the width of the screen
# basic setup
# firing range
range <- 500
deltas <- seq(100, range, 100)
target_size <- 10
# firing mechanics
power_low <- 50
power_hi <- 100
power_range <- power_hi-power_low
angle_low <- 30
angle_high <- 30
angle_range <- angle_high-angle_low
# world parameters
gravity <- 10
height <- 0
wind <- 0
# to do the noise... we will use the proportion of total power/10
# as the sd for a normal distribution
# then draw a random number from here and multiply the
# power by that value to add noise
# # setup data frame
# df <- tibble(iter = numeric(),
#              pwr = numeric(),
#              ang = numeric(),
#              true_ang = numeric(),
#              x = numeric(),
#              y = numeric())
#
# max_iter <- 100
#
# # let's do some sims...
# # vary angle with power and not the power itself?
# # actually... put the noise on the power instead of an
# # new idea... people only choose the power since angle + power would be hard...
# for(ii in 1:max_iter){
#   print(paste((ii/max_iter)*100, "%", sep = ""))
#   for(pwr in seq(power_low, power_hi, 10)){
#     # get power noise
#     # multiplying by some value to put thins on a nice scale so noise becomes a problem
#     noise <- ((pwr - power_low)/power_range)*3
#     for(ang in seq(angle_low, angle_high, 15)){
#       # now get angle with noise
#       # ang_prop <- (ang - angle_low)/angle_range
#       # ang_real <- (ang_prop + rnorm(1, 0, noise))
#       # ang_real <- ang_real * angle_range + angle_low
#       ang_real <- ang + (rnorm(1, 0, noise))
#       # maybe work out flight time here then we know how many values for t to use?
#       for(t in seq(0,20,.1)){
#         coords <- parab_mk3(t, height, gravity, pwr, ang_real, 0)
#
#         df <- rbind(df, tibble(iter = ii,
#                                pwr = pwr,
#                                ang = ang,
#                                true_ang = ang_real,
#                                x = coords$x,
#                                y = coords$y))
#         if(coords$y < 0){
#           break
#         }
#       }
#     }
#   }
# }
#
# # plot this
# df %>%
#   mutate(ang = as.factor(ang),
#          pwr = as.factor(pwr)) %>%
#   ggplot(aes(x, y,
#              colour = pwr)) +
#   geom_point(alpha = .1) +
#   facet_wrap(~ang)
# # dist of landing pos
# df %>%
#   filter(y < 0) %>%
#   mutate(pwr = as.factor(pwr)) %>%
#   ggplot(aes(x,
#              colour = pwr,
#              fill = pwr)) +
#   geom_density(alpha = .3) +
#   # geom_histogram(position = "dodge",
#   #                binwidth = .1,
#   #                aes(y = ..density..)) +
#   facet_wrap(~pwr, scales = "free_y")
#
#### Sim some trials for difference distances ####
# probably need a new function to sort out the noise part
# basically, if the power is below 50, noise = 0
# then as it gets larger than 50, we can make things a bit harder
# then do 12 trials at 10 distances?
# After this, we can look at the curve produced from this to see how accuracy
# changes over distance for an agent that "knows" how much power to use
# This should be similar to the throwing task
# set some parameters
power_range <- 100                 # set range of power
angle <- 30                        # keep angle constant
deltas <- c(1,seq(100, 1000, 100)) # set deltas
num_trials <- 500
target_size <- 10
# world parameters
gravity <- 10
height <- 0
wind <- 0
# setup df
df_sim <- tibble(trial = numeric(),
gravity = numeric(),
height = numeric(),
wind = numeric(),
delta = numeric(),
velocity = numeric(),
true_angle = numeric(),
end_pos = numeric(),
success = numeric())
# sim some trials
for(d in deltas){
pwr <- find_vel(d, angle, gravity)
lower_bound = d - target_size
upper_bound = d + target_size
for(ii in 1:num_trials){
noise <- add_noise(pwr, power_range, scale = 3, drop_point = .3)
true_angle <- angle + rnorm(1, 0, noise)
end_pos <- find_range(pwr, true_angle, gravity)
# did we hit?
if(end_pos < upper_bound & end_pos > lower_bound){
success <- 1
} else {
success <- 0
}
#add to frame
df_sim <- rbind(df_sim, tibble(trial = ii,
gravity = gravity,
height = height,
wind = wind,
delta = d,
velocity = pwr,
true_angle = true_angle,
end_pos = end_pos,
success = success))
}
}
# plot a fit
df_sim %>%
group_by(delta) %>%
mutate(acc = mean(success)) %>%
ggplot(aes(delta, acc)) +
geom_point() +
geom_smooth(aes(y = success),
method = glm,
method.args = list(family = "binomial"),
se = F)
head(df_sim)
df_sim %>%
filter(delta > 1) %>%
mutate(delta = as.factor(delta)) %>%
ggplot(aes(end_pos, colour = delta,
fill = delta)) +
geom_histogram(alpha = .3) +
facet_wrap(~delta, scales = "free")
df_sim %>%
filter(delta > 1) %>%
mutate(delta = as.factor(delta)) %>%
ggplot(aes(end_pos, colour = delta,
fill = delta)) +
geom_histogram(alpha = .3) +
facet_wrap(~delta)
df_sim %>%
filter(delta > 1) %>%
mutate(delta = as.factor(delta),
lower = delta - target_size,
upper = delta + target_size) %>%
ggplot(aes(end_pos, colour = delta,
fill = delta)) +
geom_histogram(alpha = .3) +
geom_vline(xintercept = upper,
linetype = "dashed") +
geom_vline(xintercept = lower,
linetype = "dashed")
facet_wrap(~delta)
# plots of ending position
df_sim %>%
filter(delta > 1) %>%
mutate(
lower = delta - target_size,
upper = delta + target_size,
delta = as.factor(delta)) %>%
ggplot(aes(end_pos, colour = delta,
fill = delta)) +
geom_histogram(alpha = .3) +
geom_vline(xintercept = upper,
linetype = "dashed") +
geom_vline(xintercept = lower,
linetype = "dashed") +
facet_wrap(~delta)
df_sim %>%
filter(delta > 1) %>%
mutate(lower = delta - target_size,
upper = delta + target_size,
delta = as.factor(delta))
df_sim %>%
filter(delta > 1) %>%
mutate(lower = delta - target_size,
upper = delta + target_size,
delta = as.factor(delta)) %>%
ggplot(aes(end_pos, colour = delta,
fill = delta)) +
geom_histogram(alpha = .3) +
geom_vline(aes(xintercept = upper),
linetype = "dashed") +
geom_vline(aes(xintercept = lower),
linetype = "dashed") +
facet_wrap(~delta)
df_sim %>%
filter(delta > 1) %>%
mutate(lower = delta - target_size,
upper = delta + target_size,
delta = as.factor(delta)) %>%
ggplot(aes(end_pos, colour = delta,
fill = delta)) +
geom_histogram(alpha = .3) +
geom_vline(aes(xintercept = upper),
linetype = "dashed") +
geom_vline(aes(xintercept = lower),
linetype = "dashed") +
facet_wrap(~delta, scales = "free")
install.packages("patchwork")
library(patchwork)
plts <- plt_curve + plt_dist
# plot a fit
plt_curve <- df_sim %>%
group_by(delta) %>%
mutate(acc = mean(success)) %>%
ggplot(aes(delta, acc)) +
geom_point() +
geom_smooth(aes(y = success),
method = glm,
method.args = list(family = "binomial"),
se = F)
# plots of ending position
plt_dist <- df_sim %>%
filter(delta > 1) %>%
mutate(lower = delta - target_size,
upper = delta + target_size,
delta = as.factor(delta)) %>%
ggplot(aes(end_pos, colour = delta,
fill = delta)) +
geom_histogram(alpha = .3) +
geom_vline(aes(xintercept = upper),
linetype = "dashed") +
geom_vline(aes(xintercept = lower),
linetype = "dashed") +
facet_wrap(~delta, scales = "free")
# put together
library(patchwork)
plts <- plt_curve + plt_dist
plts
plt_curve <- df_sim %>%
group_by(delta) %>%
mutate(acc = mean(success)) %>%
ggplot(aes(delta, acc)) +
geom_point() +
geom_smooth(aes(y = success),
method = glm,
method.args = list(family = "binomial"),
se = F) +
theme_bw()
# plots of ending position
plt_dist <- df_sim %>%
filter(delta > 1) %>%
mutate(lower = delta - target_size,
upper = delta + target_size,
delta = as.factor(delta)) %>%
ggplot(aes(end_pos, colour = delta,
fill = delta)) +
geom_histogram(alpha = .3) +
geom_vline(aes(xintercept = upper),
linetype = "dashed") +
geom_vline(aes(xintercept = lower),
linetype = "dashed") +
facet_wrap(~delta, scales = "free") +
theme_bw() +
theme(legend.position = "none")
# put together
library(patchwork)
plts <- plt_curve + plt_dist
plts
df_sim %>%
filter(delta > 1) %>%
mutate(lower = delta - target_size,
upper = delta + target_size,
delta = as.factor(delta)) %>%
ggplot(aes(end_pos, colour = delta,
fill = delta)) +
geom_histogram(alpha = .3) +
geom_vline(aes(xintercept = upper),
linetype = "dashed") +
geom_vline(aes(xintercept = lower),
linetype = "dashed") +
facet_wrap(~delta, scales = "free") +
theme_bw() +
theme(legend.position = "none")
plts <- plt_curve + plt_dist
plts
plt_dist <- df_sim %>%
filter(delta > 1) %>%
mutate(lower = delta - target_size,
upper = delta + target_size,
delta = as.factor(delta)) %>%
ggplot(aes(end_pos, colour = delta,
fill = delta)) +
geom_histogram(alpha = .3) +
geom_vline(aes(xintercept = upper),
linetype = "dashed") +
geom_vline(aes(xintercept = lower),
linetype = "dashed") +
facet_wrap(~delta) +#, scales = "free") +
theme_bw() +
theme(legend.position = "none")
# put together
library(patchwork)
plts <- plt_curve + plt_dist
plts
((1*805) + (5 * 1264) + (10 * 106))
((1*805) + (5 * 1264) + (10 * 106)) * 12
((1 * 820) + (5 * 1296) + (10 * 116) + (20 * 223) + (50 * 46))
((1 * 820) + (5 * 1296) + (10 * 116) + (20 * 223) + (50 * 46)) * 12
R.version
setwd("~/")
setwd("F:/Uni/Github/Breaking_symmetry/Supplementary")
library(tidyverse)
library(brms)
library(tidybayes)
load("../Analyses/Experiment_2_Two_throw/scratch/model_data_pos")
source("extract_draws_functions/Two_throw_draws.R")
Two_throw_priors <- brm(abspos ~ norm_delta * Num_throws + (norm_delta * Num_throws|Participant),
family = "beta",
data = model_data_pos,
prior = c(set_prior("student_t(4,0,.8)",
class = "b",
coef = "norm_delta"),
set_prior("student_t(4,0,.8)",
class = "b",
coef = "norm_delta:Num_throwsTwoMThrows"),
set_prior("student_t(4,0,.8)",
class = "b", coef = "Num_throwsTwoMThrows"),
set_prior("student_t(4,0,.8)",
class = "Intercept")),
cores = 1,
chains = 1,
iter = 10000,
warmup = 5000,
control = list(adapt_delta = .99, max_treedepth = 15),
sample_prior = "only")
test <- draw_post_delta(Two_throw_priors)
test <- draw_post_delta(Two_throw_priors, model_Data_pos)
test <- draw_post_delta(Two_throw_priors, model_data_pos)
test
draw_post_delta
draws_df <- draw_post_delta(Two_throw_priors, model_data_pos)
head(draws_df)
