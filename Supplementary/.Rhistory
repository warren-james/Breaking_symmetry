# range given angle and effect of gravity
# find velocity needed for range X
find_vel <- function(range, angle, gravity){
radians <- angle*(pi/180)
vel <- sqrt(range/(sin(2*radians)/gravity))
return(vel)
}
# find range so we know where it should land?
find_range <- function(velocity, angle, gravity){
radians <- angle*(pi/180)
range <- velocity^2 * sin(2*radians)/gravity
return(range)
}
# sort out noise function
# this will take a velocity and decide how much noise there should be
add_noise <- function(velocity, power_range, scale, drop_point){
low <- power_range*drop_point
if(velocity <= low){
noise <- 0
} else {
# multiply by some constant... this can be tweaked to increase noise
# with distance...
noise <- ((velocity - low)/power_range)*scale
}
return(noise)
}
# above should be all the formulas we need to make the
# avatar perform the task
#### show results ####
# this part just draws some traces of various angles and powers to make sure that the functions
# work the way they were intended to... so no need to run this part if you trust my functions
# setup params
# t <- seq(0,10,.01)
# a <- 30# seq(15,75,15)
# g <- 10
# v <- seq(50,100,10)
# h <- 0
#
# # setup tibble
# temp <- tibble(time = rep(t, length(a) * length(v)),
#                angle = rep(a, each = length(v) * length(t)),
#                velocity = rep(rep(v, each = length(t)), length(a)),
#                gravity = g,
#                height = h,
#                y = parab_mk3(time, height, gravity, velocity, angle)$y,
#                x = parab_mk3(time, height, gravity, velocity, angle)$x)
#
# # plot this
# temp %>%
#   mutate(angle = as.factor(angle),
#          y = ifelse(y <= 0, 0, y)) %>%
#   ggplot(aes(x, y,
#              colour = angle)) +
#   # geom_point(alpha = .1) +
#   geom_line() +
#   scale_y_continuous(limits = c(0,1000)) +
#   facet_wrap(~velocity)
#### Simulating ####
# so this looks good now, the function works
# so let's simulate some trials
# to do this, we need to set some parameters so we can keep things constant
# and maybe allow participants to do something...
# we need to be able to specify the width of the screen
# basic setup
# firing range
range <- 500
deltas <- seq(100, range, 100)
target_size <- 10
# firing mechanics
power_low <- 50
power_hi <- 100
power_range <- power_hi-power_low
angle_low <- 30
angle_high <- 30
angle_range <- angle_high-angle_low
# world parameters
gravity <- 10
height <- 0
wind <- 0
# to do the noise... we will use the proportion of total power/10
# as the sd for a normal distribution
# then draw a random number from here and multiply the
# power by that value to add noise
# # setup data frame
# df <- tibble(iter = numeric(),
#              pwr = numeric(),
#              ang = numeric(),
#              true_ang = numeric(),
#              x = numeric(),
#              y = numeric())
#
# max_iter <- 100
#
# # let's do some sims...
# # vary angle with power and not the power itself?
# # actually... put the noise on the power instead of an
# # new idea... people only choose the power since angle + power would be hard...
# for(ii in 1:max_iter){
#   print(paste((ii/max_iter)*100, "%", sep = ""))
#   for(pwr in seq(power_low, power_hi, 10)){
#     # get power noise
#     # multiplying by some value to put thins on a nice scale so noise becomes a problem
#     noise <- ((pwr - power_low)/power_range)*3
#     for(ang in seq(angle_low, angle_high, 15)){
#       # now get angle with noise
#       # ang_prop <- (ang - angle_low)/angle_range
#       # ang_real <- (ang_prop + rnorm(1, 0, noise))
#       # ang_real <- ang_real * angle_range + angle_low
#       ang_real <- ang + (rnorm(1, 0, noise))
#       # maybe work out flight time here then we know how many values for t to use?
#       for(t in seq(0,20,.1)){
#         coords <- parab_mk3(t, height, gravity, pwr, ang_real, 0)
#
#         df <- rbind(df, tibble(iter = ii,
#                                pwr = pwr,
#                                ang = ang,
#                                true_ang = ang_real,
#                                x = coords$x,
#                                y = coords$y))
#         if(coords$y < 0){
#           break
#         }
#       }
#     }
#   }
# }
#
# # plot this
# df %>%
#   mutate(ang = as.factor(ang),
#          pwr = as.factor(pwr)) %>%
#   ggplot(aes(x, y,
#              colour = pwr)) +
#   geom_point(alpha = .1) +
#   facet_wrap(~ang)
# # dist of landing pos
# df %>%
#   filter(y < 0) %>%
#   mutate(pwr = as.factor(pwr)) %>%
#   ggplot(aes(x,
#              colour = pwr,
#              fill = pwr)) +
#   geom_density(alpha = .3) +
#   # geom_histogram(position = "dodge",
#   #                binwidth = .1,
#   #                aes(y = ..density..)) +
#   facet_wrap(~pwr, scales = "free_y")
#
#### Sim some trials for difference distances ####
# probably need a new function to sort out the noise part
# basically, if the power is below 50, noise = 0
# then as it gets larger than 50, we can make things a bit harder
# then do 12 trials at 10 distances?
# After this, we can look at the curve produced from this to see how accuracy
# changes over distance for an agent that "knows" how much power to use
# This should be similar to the throwing task
# set some parameters
power_range <- 100            # set range of power
angle <- 30                   # keep angle constant
deltas <- seq(100, 1000, 100) # set deltas
num_trials <- 200
target_size <- 10
# world parameters
gravity <- 10
height <- 0
wind <- 0
# setup df
df_sim <- tibble(trial = numeric(),
gravity = numeric(),
height = numeric(),
wind = numeric(),
delta = numeric(),
velocity = numeric(),
true_angle = numeric(),
end_pos = numeric(),
success = numeric())
# sim some trials
for(d in deltas){
pwr <- find_vel(d, angle, gravity)
lower_bound = d - target_size
upper_bound = d + target_size
for(ii in 1:num_trials){
noise <- add_noise(pwr, power_range, scale = 3, drop_point = .4)
true_angle <- angle + rnorm(1, 0, noise)
end_pos <- find_range(pwr, true_angle, gravity)
# did we hit?
if(end_pos < upper_bound & end_pos > lower_bound){
success <- 1
} else {
success <- 0
}
#add to frame
df_sim <- rbind(df_sim, tibble(trial = ii,
gravity = gravity,
height = height,
wind = wind,
delta = d,
velocity = pwr,
true_angle = true_angle,
end_pos = end_pos,
success = success))
}
}
# plot a fit
df_sim %>%
group_by(delta) %>%
summarise(acc = mean(success)) %>%
ggplot(aes(delta, acc)) +
geom_point() +
geom_smooth(method = glm,
method.args = list(family = "binomial"),
se = F)
df_sim %>%
group_by(delta) %>%
mutate(acc = mean(success)) %>%
ggplot(aes(delta, acc)) +
geom_point() +
geom_smooth(aes(y = success),
method = glm,
method.args = list(family = "binomial"),
se = F)
View(df_sim)
power_range <- 100            # set range of power
angle <- 30                   # keep angle constant
deltas <- seq(100, 1000, 100) # set deltas
num_trials <- 200
target_size <- 10
# world parameters
gravity <- 10
height <- 0
wind <- 0
# setup df
df_sim <- tibble(trial = numeric(),
gravity = numeric(),
height = numeric(),
wind = numeric(),
delta = numeric(),
velocity = numeric(),
true_angle = numeric(),
end_pos = numeric(),
success = numeric())
# sim some trials
for(d in deltas){
pwr <- find_vel(d, angle, gravity)
lower_bound = d - target_size
upper_bound = d + target_size
for(ii in 1:num_trials){
noise <- add_noise(pwr, power_range, scale = 3, drop_point = .3)
true_angle <- angle + rnorm(1, 0, noise)
end_pos <- find_range(pwr, true_angle, gravity)
# did we hit?
if(end_pos < upper_bound & end_pos > lower_bound){
success <- 1
} else {
success <- 0
}
#add to frame
df_sim <- rbind(df_sim, tibble(trial = ii,
gravity = gravity,
height = height,
wind = wind,
delta = d,
velocity = pwr,
true_angle = true_angle,
end_pos = end_pos,
success = success))
}
}
# plot a fit
df_sim %>%
group_by(delta) %>%
mutate(acc = mean(success)) %>%
ggplot(aes(delta, acc)) +
geom_point() +
geom_smooth(aes(y = success),
method = glm,
method.args = list(family = "binomial"),
se = F)
power_range <- 100                 # set range of power
angle <- 30                        # keep angle constant
deltas <- c(1,seq(100, 1000, 100)) # set deltas
num_trials <- 200
target_size <- 10
# world parameters
gravity <- 10
height <- 0
wind <- 0
# setup df
df_sim <- tibble(trial = numeric(),
gravity = numeric(),
height = numeric(),
wind = numeric(),
delta = numeric(),
velocity = numeric(),
true_angle = numeric(),
end_pos = numeric(),
success = numeric())
# sim some trials
for(d in deltas){
pwr <- find_vel(d, angle, gravity)
lower_bound = d - target_size
upper_bound = d + target_size
for(ii in 1:num_trials){
noise <- add_noise(pwr, power_range, scale = 3, drop_point = .3)
true_angle <- angle + rnorm(1, 0, noise)
end_pos <- find_range(pwr, true_angle, gravity)
# did we hit?
if(end_pos < upper_bound & end_pos > lower_bound){
success <- 1
} else {
success <- 0
}
#add to frame
df_sim <- rbind(df_sim, tibble(trial = ii,
gravity = gravity,
height = height,
wind = wind,
delta = d,
velocity = pwr,
true_angle = true_angle,
end_pos = end_pos,
success = success))
}
}
# plot a fit
df_sim %>%
group_by(delta) %>%
mutate(acc = mean(success)) %>%
ggplot(aes(delta, acc)) +
geom_point() +
geom_smooth(aes(y = success),
method = glm,
method.args = list(family = "binomial"),
se = F)
power_range <- 100                 # set range of power
angle <- 30                        # keep angle constant
deltas <- c(1,seq(100, 1000, 100)) # set deltas
num_trials <- 200
target_size <- 10
# world parameters
gravity <- 10
height <- 0
wind <- 0
# setup df
df_sim <- tibble(trial = numeric(),
gravity = numeric(),
height = numeric(),
wind = numeric(),
delta = numeric(),
velocity = numeric(),
true_angle = numeric(),
end_pos = numeric(),
success = numeric())
# sim some trials
for(d in deltas){
pwr <- find_vel(d, angle, gravity)
lower_bound = d - target_size
upper_bound = d + target_size
for(ii in 1:num_trials){
noise <- add_noise(pwr, power_range, scale = 3, drop_point = .3)
true_angle <- angle + rnorm(1, 0, noise)
end_pos <- find_range(pwr, true_angle, gravity)
# did we hit?
if(end_pos < upper_bound & end_pos > lower_bound){
success <- 1
} else {
success <- 0
}
#add to frame
df_sim <- rbind(df_sim, tibble(trial = ii,
gravity = gravity,
height = height,
wind = wind,
delta = d,
velocity = pwr,
true_angle = true_angle,
end_pos = end_pos,
success = success))
}
}
# plot a fit
df_sim %>%
group_by(delta) %>%
mutate(acc = mean(success)) %>%
ggplot(aes(delta, acc)) +
geom_point() +
geom_smooth(aes(y = success),
method = glm,
method.args = list(family = "binomial"),
se = F)
power_range <- 100                 # set range of power
angle <- 30                        # keep angle constant
deltas <- c(1,seq(100, 1000, 100)) # set deltas
num_trials <- 200
target_size <- 10
# world parameters
gravity <- 10
height <- 0
wind <- 0
# setup df
df_sim <- tibble(trial = numeric(),
gravity = numeric(),
height = numeric(),
wind = numeric(),
delta = numeric(),
velocity = numeric(),
true_angle = numeric(),
end_pos = numeric(),
success = numeric())
# sim some trials
for(d in deltas){
pwr <- find_vel(d, angle, gravity)
lower_bound = d - target_size
upper_bound = d + target_size
for(ii in 1:num_trials){
noise <- add_noise(pwr, power_range, scale = 3, drop_point = .3)
true_angle <- angle + rnorm(1, 0, noise)
end_pos <- find_range(pwr, true_angle, gravity)
# did we hit?
if(end_pos < upper_bound & end_pos > lower_bound){
success <- 1
} else {
success <- 0
}
#add to frame
df_sim <- rbind(df_sim, tibble(trial = ii,
gravity = gravity,
height = height,
wind = wind,
delta = d,
velocity = pwr,
true_angle = true_angle,
end_pos = end_pos,
success = success))
}
}
# plot a fit
df_sim %>%
group_by(delta) %>%
mutate(acc = mean(success)) %>%
ggplot(aes(delta, acc)) +
geom_point() +
geom_smooth(aes(y = success),
method = glm,
method.args = list(family = "binomial"),
se = F)
df_sim %>%
group_by(delta) %>%
mutate(acc = mean(success)) %>%
ggplot(aes(delta, acc)) +
geom_point() +
geom_smooth(#aes(y = success),
method = glm,
method.args = list(family = "binomial"),
se = F)
power_range <- 100                 # set range of power
angle <- 30                        # keep angle constant
deltas <- c(1,seq(100, 1000, 100)) # set deltas
num_trials <- 500
target_size <- 10
# world parameters
gravity <- 10
height <- 0
wind <- 0
# setup df
df_sim <- tibble(trial = numeric(),
gravity = numeric(),
height = numeric(),
wind = numeric(),
delta = numeric(),
velocity = numeric(),
true_angle = numeric(),
end_pos = numeric(),
success = numeric())
# sim some trials
for(d in deltas){
pwr <- find_vel(d, angle, gravity)
lower_bound = d - target_size
upper_bound = d + target_size
for(ii in 1:num_trials){
noise <- add_noise(pwr, power_range, scale = 3, drop_point = .3)
true_angle <- angle + rnorm(1, 0, noise)
end_pos <- find_range(pwr, true_angle, gravity)
# did we hit?
if(end_pos < upper_bound & end_pos > lower_bound){
success <- 1
} else {
success <- 0
}
#add to frame
df_sim <- rbind(df_sim, tibble(trial = ii,
gravity = gravity,
height = height,
wind = wind,
delta = d,
velocity = pwr,
true_angle = true_angle,
end_pos = end_pos,
success = success))
}
}
# plot a fit
df_sim %>%
group_by(delta) %>%
mutate(acc = mean(success)) %>%
ggplot(aes(delta, acc)) +
geom_point() +
geom_smooth(aes(y = success),
method = glm,
method.args = list(family = "binomial"),
se = F)
setwd("F:/Uni/Github/Breaking_symmetry/Supplementary")
