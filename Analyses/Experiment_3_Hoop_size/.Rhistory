head(dat)
m <- map2stan(
alist(
x ~ dbeta(shape1, shape2),
shape1 ~ dcauchy(0,1),
shape2 ~ dcauchy(0,1)),
data = dat)
View(dat)
m <- map2stan(
alist(
x ~ dbetabinom(shape1, shape2),
shape1 ~ dcauchy(0,1),
shape2 ~ dcauchy(0,1)),
data = dat)
m <- map2stan(
alist(
x ~ dbeta2(shape1, shape2),
shape1 ~ dcauchy(0,1),
shape2 ~ dcauchy(0,1)),
data = dat)
install.packages(c("backports", "bayesplot", "BH", "bindr", "bindrcpp", "brms", "Brobdingnag", "broom", "callr", "caTools", "clipr", "curl", "DBI", "dbplyr", "devtools", "digest", "dplyr", "DT", "dygraphs", "evaluate", "forcats", "ggplot2", "ggthemes", "git2r", "glue", "gtools", "haven", "highr", "hms", "htmlwidgets", "httpuv", "igraph", "inline", "installr", "knitr", "lme4", "loo", "lubridate", "matrixStats", "miniUI", "modelr", "munsell", "mvtnorm", "nleqslv", "openssl", "packrat", "plogr", "psych", "purrr", "R.oo", "Rcpp", "RcppEigen", "RCurl", "readxl", "reprex", "reshape2", "rlang", "rmarkdown", "rprojroot", "rsconnect", "rstan", "rstantools", "selectr", "shiny", "shinystan", "sourcetools", "StanHeaders", "stringi", "stringr", "tibble", "tidyr", "tidyselect", "viridisLite", "withr", "xml2", "xts", "yaml", "zoo"))
install.packages(c("backports", "bayesplot", "BH", "bindr", "bindrcpp", "brms", "Brobdingnag", "broom", "callr", "caTools", "clipr", "curl", "DBI", "dbplyr", "devtools", "digest", "dplyr", "DT", "dygraphs", "evaluate", "forcats", "ggplot2", "ggthemes", "git2r", "glue", "gtools", "haven", "highr", "hms", "htmlwidgets", "httpuv", "igraph", "inline", "installr", "knitr", "lme4", "loo", "lubridate", "matrixStats", "miniUI", "modelr", "munsell", "mvtnorm", "nleqslv", "openssl", "packrat", "plogr", "psych", "purrr", "R.oo", "Rcpp", "RcppEigen", "RCurl", "readxl", "reprex", "reshape2", "rlang", "rmarkdown", "rprojroot", "rsconnect", "rstan", "rstantools", "selectr", "shiny", "shinystan", "sourcetools", "StanHeaders", "stringi", "stringr", "tibble", "tidyr", "tidyselect", "viridisLite", "withr", "xml2", "xts", "yaml", "zoo"))
install.packages(c("backports", "bayesplot", "BH", "bindr", "bindrcpp", "brms", "Brobdingnag", "broom", "callr", "caTools", "clipr", "curl", "DBI", "dbplyr", "devtools", "digest", "dplyr", "DT", "dygraphs", "evaluate", "forcats", "ggplot2", "ggthemes", "git2r", "glue", "gtools", "haven", "highr", "hms", "htmlwidgets", "httpuv", "igraph", "inline", "installr", "knitr", "lme4", "loo", "lubridate", "matrixStats", "miniUI", "modelr", "munsell", "mvtnorm", "nleqslv", "openssl", "packrat", "plogr", "psych", "purrr", "R.oo", "Rcpp", "RcppEigen", "RCurl", "readxl", "reprex", "reshape2", "rlang", "rmarkdown", "rprojroot", "rsconnect", "rstan", "rstantools", "selectr", "shiny", "shinystan", "sourcetools", "StanHeaders", "stringi", "stringr", "tibble", "tidyr", "tidyselect", "viridisLite", "withr", "xml2", "xts", "yaml", "zoo"))
install.packages(c("backports", "bayesplot", "BH", "bindr", "bindrcpp", "brms", "Brobdingnag", "broom", "callr", "caTools", "clipr", "curl", "DBI", "dbplyr", "devtools", "digest", "dplyr", "DT", "dygraphs", "evaluate", "forcats", "ggplot2", "ggthemes", "git2r", "glue", "gtools", "haven", "highr", "hms", "htmlwidgets", "httpuv", "igraph", "inline", "installr", "knitr", "lme4", "loo", "lubridate", "matrixStats", "miniUI", "modelr", "munsell", "mvtnorm", "nleqslv", "openssl", "packrat", "plogr", "psych", "purrr", "R.oo", "Rcpp", "RcppEigen", "RCurl", "readxl", "reprex", "reshape2", "rlang", "rmarkdown", "rprojroot", "rsconnect", "rstan", "rstantools", "selectr", "shiny", "shinystan", "sourcetools", "StanHeaders", "stringi", "stringr", "tibble", "tidyr", "tidyselect", "viridisLite", "withr", "xml2", "xts", "yaml", "zoo"))
library(tidyverse)
library(rethinking)
# simulate some proportion data
dat <- data.frame(x = rbeta(100, 3, 1.8))
# fit Beta distributon to data
m <- map2stan(
alist(
x ~ dbeta(shape1, shape2),
shape1 ~ dcauchy(0,1),
shape2 ~ dcauchy(0,1)),
data = dat)
summary(m)
n_samples = 100
post <- extract.samples(m, n_samples)
x <- seq(0,1, 0.01)
y <- dbeta(seq(0,1, 0.01), shape1 = 2, shape2 = 2)
p <- unlist(map2(post$shape1, post$shape2, dbeta, x  = x ))
n <- rep(1:n_samples, each = length(x))
fits <- tibble(x = rep(x, n_samples), p , n = n)
post <- extract.samples(m)
mu <- HPDI(with(post, shape1 / (shape1 + shape2), prob = 0.99))
plt <- ggplot()
plt <- plt + geom_density(data = dat,aes(x = dat$x), fill = "#ec9844", colour = "#ec9844", adjust = 1/2)
plt <- plt + geom_rect(aes(xmin = mu[1], xmax = mu[2], ymin = 0, ymax = Inf), fill = "blue", alpha = 0.3)
plt <- plt + geom_path(data = fits, aes(x = x, y = p, group = n), alpha = 0.1, size = 1)
plt <- plt + scale_x_continuous("proporiton", expand = c(0,0))
plt <- plt + scale_y_continuous("density", expand = c(0,0), limits = c(0, 2))
plt <- plt + theme_bw()
plt
n = 1000
dat <- data.frame(
x = c(rbeta(n, 3, 2), rbeta(n, 1, 2)),
z = rep(0:1, each = n))
plt <- ggplot(dat)
plt <- plt + geom_density(
aes(x = dat$x, fill = as.factor(dat$z)), adjust = 1/2)
plt
head(dat)
setwd("E:/Github/Breaking_symmetry/Analyses/Experiment_3_Hoop_size")
dir()
load("data/Part_2/Part2_measures.txt")
load("temp/beanbagdat")
View(beanbagdat)
df_part2 <- read.csv("data/Part_2/Part2_measures.txt")
View(df_part2)
df_part2 <- read.csv("data/Part_2/Part2_measures.txt", sep = "\t")
View(df_part2)
rm(list = ls())
#### level 3 - 2nd Semester 2017/18 ####
# Part 2 Standing position script
# This script looks at where participants stood on each trial and
# also where they should have stood for the optimal strategy. Also,
# it looks at where they would have stood if they were trying to
# achieve equal accuracy for both hoop sizes.
# Written by Warren James
#### Load in the libraries ####
library(tidyverse)
library(reshape2)
library(lme4)
#### Constants ####
Hoop_size <- 0.46
#### Created functions ####
# normalising distance function
norm_dist <- function(x,y){
2*(x - (y*-1))/(y - (y*-1))-1
}
#### read in the data ####
dat <- read.csv("data/Part_2/Part2_measures.txt", sep = "\t")
#### Pre-process data ####
# sort out participant coding
dat$participant <- paste(dat$experimenter, dat$participant, sep = "_")
dat$participant <- as.factor(dat$participant)
# drop experimenter column
dat <- dat[ , !(names(dat) %in% "experimenter")]
# make all colour values the same
# sort red
dat$colour[dat$colour == "Red"] <- "R"
# sort yellow
dat$colour[dat$colour == "y"] <- "Y"
dat$colour[dat$colour == " Y"] <- "Y"
dat$colour[dat$colour == "Y "] <- "Y"
dat$colour[dat$colour == "Y  "] <- "Y"
dat$colour[dat$colour == "Y   "] <- "Y"
dat$colour[dat$colour == "Yellow"] <- "Y"
dat$colour[dat$colour == "Yellow "] <- "Y"
dat$colour[dat$colour == "yellow"] <- "Y"
# sort blue
dat$colour[dat$colour == "Blue"] <- "B"
dat$colour[dat$colour == "Blue "] <- "B"
# unique order now B Y R
# remove unused levels
dat$colour <- factor(dat$colour)
# reorder levels
dat$colour <- factor(dat$colour,
levels(dat$colour)[c(1,3,2)])
# add in hoop_position
for (row in 1:nrow(dat))
{
dat$hoop_pos[row] = dat[row,as.character(dat$colour[row])]
}
# tidy
rm(row)
# create columns to fill
dat$small_pos <- 0
dat$large_pos <- 0
#### input small hoop pos ####
# rownames used so it doesn't loop over the first 15 rows...
for(i in levels(dat$participant)){
a <- 10
for(x in levels(dat$colour)){
for(z in rownames(dat[dat$colour == x & dat$participant == i,])){
q <- as.numeric(z)
if(unique(dat[q,a]) == "large"){
dat$small_pos[q] <- dat$hoop_pos[q]*-1
} else {
dat$small_pos[q] <-  dat$hoop_pos[q]
}
}
a <- a + 1
}
}
# tidy
rm(a,i,q,x,z)
# add in large pos
dat$large_pos <- dat$small_pos*-1
#### load in data from part 1 ####
# part1 acc measures
load("temp/beanbagdat")
# slabs to test
load("temp/slabs_to_test")
#### normalising distance data ####
# this means we need to make all large hoops negative and standing towards these negative values too
# Also, make small hoops positive, and the standing positions closer to small hoops
# Can do this based on position data; probably separate it out...
norm_dat <- dat
# can probably loop through it?
for(i in levels(norm_dat$participant)){
for(z in rownames(norm_dat[norm_dat$large_pos > 0 & norm_dat$participant == i,])){
q <- as.numeric(z)
norm_dat$small_pos[q] <- norm_dat$small_pos[q] *-1
norm_dat$subject_position[q] <- norm_dat$subject_position[q]*-1
norm_dat$large_pos[q] <- norm_dat$large_pos[q]*-1
}
}
# tidy
rm(i, q, z)
# apply the normalising distance function
norm_dat$norm_dist <- norm_dist(norm_dat$subject_position, norm_dat$hoop_pos)
#### work out opt switching point ####
# create empty data.frame to get partcipants accuracy across all hoop separations
acc_slab <- data.frame(participant = character(),
hoop_size = character(),
slab = numeric(),
acc = numeric())
# create data.frame for just the switch point
switch_slab <- data.frame(participant = character(),
hoop_size = character(),
slab = numeric())
# set distances to be estimated
dist_seq <- seq(0,38,0.5)
for(x in unique(beanbagdat$participant))
{
for(i in unique(beanbagdat$hoop_size))
{
ss = beanbagdat[beanbagdat$participant==x & beanbagdat$hoop_size==i,]
m = glm(data=ss, cbind(inhoop, trials-inhoop)~slab+0,
offset=ss$off_set, binomial)
for(a in unique(dist_seq))
{
p = predict(m, data.frame(slab=a), type="response")
p = as.numeric(p)
acc_slab <- rbind(acc_slab, data.frame(participant = x,
hoop_size = i,
slab = a,
acc = round(p[1], digits = 7)))
}
slab = max(which(predict(m, data.frame(slab=dist_seq), type='response')>0.5))
b = dist_seq[slab]
switch_slab <- rbind(switch_slab, data.frame(participant = x,
hoop_size = i,
slab = b))
}
}
# tidy
rm(ss, m, a, i, p, x, b, slab, dist_seq)
# get switch points for small hoops
switch_slab_sm <- switch_slab[switch_slab$hoop_size == "small",]
switch_slab_sm <- switch_slab_sm[,c("participant",
"slab")]
colnames(switch_slab_sm) <- c("participant", "switchSlab_sm")
# now for large
switch_slab_la <- switch_slab[switch_slab$hoop_size == "large",]
switch_slab_la <- switch_slab_la[,c("participant",
"slab")]
colnames(switch_slab_la) <- c("participant", "switchSlab_la")
# get switch pos depending on average dist
# this is to reflect the point at which participants can't maintain
# an average acc of 50%
switch_slab_both <- merge(switch_slab_la, switch_slab_sm)
switch_slab_both$switchSlab <- (switch_slab_both$switchSlab_la +
switch_slab_both$switchSlab_sm)/2
switch_slab_both <- switch_slab_both[,c("participant", "switchSlab")]
# create switchSlab column in norm_dat
norm_dat <- merge(switch_slab_both, norm_dat)
# tidy
rm(switch_slab, switch_slab_la, switch_slab_sm, switch_slab_both)
#### get even acc stand dist ####
# get small distances first
temp_small <- melt(slabs_to_test[slabs_to_test$hoop_size == "small",],
id = c("participant", "hoop_size"))
temp_small <- temp_small[,c("participant",
"value")]
colnames(temp_small) <- c("participant",
"small_hoop_dist")
# now get avg dists
temp_avg <- melt(slabs_to_test[slabs_to_test$hoop_size == "avg",],
id = c("participant",
"hoop_size"))
temp_avg <- temp_avg[,c("participant",
"value")]
colnames(temp_avg) <- c("participant",
"avg_hoop_dist")
# tidy
rm(slabs_to_test)
# merge data sets
temp_avg_small <- cbind(temp_avg, temp_small)
temp_avg_small <- temp_avg_small[,c("participant",
"avg_hoop_dist",
"small_hoop_dist")]
colnames(temp_avg_small) <- c("participant",
"hoop_pos",
"small_hoop_dist")
# get the amount of shift towards the small hoop
temp_avg_small$shift <- temp_avg_small$hoop_pos - temp_avg_small$small_hoop_dist
# remove small_hoop_dist
temp_avg_small <- temp_avg_small[,c("participant",
"hoop_pos",
"shift")]
# add this into norm_dat
norm_dat <- merge(temp_avg_small, norm_dat)
# reorder columns so it's clearer
norm_dat <- norm_dat[,c("participant",
"trial",
"colour",
"direction",
"subject_position",
"accuracy",
"R",
"Y",
"B",
"B_N_Size",
"Y_N_Size",
"R_N_Size",
"hoop_pos",
"small_pos",
"large_pos",
"norm_dist",
"switchSlab",
"shift")]
# tidy
rm(temp_avg, temp_avg_small, temp_small)
head(norm_dat)
View(norm_dat)
save(norm_dat, file = "scratch/df_part2_norm")
load("scratch/df_part2_norm")
rm(list = ls())
#### Modelling and plotting Hoop Size ####
#
#### Library ####
library(brms)
library(rstan)
library(tidybayes)
library(tidyverse)
#### Constants ####
Hoop_size <- 0.46
#### Functions ####
#### Load in data ####
load("scratch/df_part2_norm")
head(norm_dat)
View(norm_dat)
range(norm_dat$large_pos)
range(norm_dat$small_pos)
select(participant, hoop_pos, norm_dist)
model_data <- norm_dat %>%
select(participant, hoop_pos, norm_dist)
View(model_data)
model_data <- norm_dat %>%
select(participant, hoop_pos, norm_dist) %>%
group_by(participant) %>%
mutate(norm_hoop_pos = hoop_pos/max(hoop_pos)) %>%
ungroup()
View(model_data)
range(model_data$norm_hoop_pos)
head(model_data)
m1 <- brms(norm_dist ~ norm_hoop_pos,
data = model_data,
family = "normal",
cores = 1,
chains = 1,
iter = 2000)
m1 <- brm(norm_dist ~ norm_hoop_pos,
data = model_data,
family = "normal",
cores = 1,
chains = 1,
iter = 2000)
summary(m1)
plot(marginal_effects(m1))
model_data %>%
ggplot(aes(norm_dist)) +
geom_density()
model_data %>%
ggplot(aes(norm_dist)) +
geom_histogram()
plt <- model_data %>%
add_predicted_draws(m1) %>%
ungroup() %>%
ggplot(aes(.prediction)) +
theme_minimal()
plt
View(plt)
View(plt[["data"]])
plt <- model_data %>%
add_predicted_draws(m1) %>%
ggplot(aes(.prediction)) +
geom_density() +
theme_minimal()
plt
# sort out data for modelling?
model_data <- norm_dat %>%
select(participant, hoop_pos, norm_dist) %>%
group_by(participant) %>%
mutate(norm_hoop_pos = hoop_pos/max(hoop_pos)) %>%
ungroup() %>%
filter(norm_dist => -1, norm_dist =< 1)
model_data <- norm_dat %>%
select(participant, hoop_pos, norm_dist) %>%
group_by(participant) %>%
mutate(norm_hoop_pos = hoop_pos/max(hoop_pos)) %>%
ungroup() %>%
filter(norm_dist >= -1, norm_dist <= 1)
model_data %>%
ggplot(aes(norm_dist)) +
geom_histogram()
m1 <- brm(norm_dist ~ norm_hoop_pos,
data = model_data,
family = "normal",
cores = 1,
chains = 1,
iter = 2000)
# plot posterior?
plt <- model_data %>%
add_predicted_draws(m1) %>%
ggplot(aes(.prediction)) +
geom_density() +
theme_minimal()
plt
model_data <- norm_dat %>%
select(participant, hoop_pos, norm_dist) %>%
group_by(participant) %>%
mutate(norm_hoop_pos = hoop_pos/max(hoop_pos)) %>%
ungroup() %>%
filter(norm_dist >= -1, norm_dist <= 1) %>%
mutate(norm_dist2 = (norm_dist + 1)/2)
View(model_data)
m2 <- brm(norm_dist2,
data = model_data,
family = "beta",
cores = 1,
chains = 1,
iter = 2000)
m2 <- brm(norm_dist2 ~ norm_hoop_pos,
data = model_data,
family = "beta",
cores = 1,
chains = 1,
iter = 2000)
range(model_data$norm_dist2)
model_data <- norm_dat %>%
select(participant, hoop_pos, norm_dist) %>%
group_by(participant) %>%
mutate(norm_hoop_pos = hoop_pos/max(hoop_pos)) %>%
ungroup() %>%
filter(norm_dist >= -1, norm_dist <= 1) %>%
mutate(norm_dist2 = (norm_dist + 1)/2 - 1e-4)
m2 <- brm(norm_dist2 ~ norm_hoop_pos,
data = model_data,
family = "beta",
cores = 1,
chains = 1,
iter = 2000)
plt <- model_data %>%
add_predicted_draws(m2) %>%
ggplot(aes(.prediction)) +
geom_density() +
theme_minimal()
plt
plot(marginal_effects(m2))
model_data <- norm_dat %>%
select(participant, hoop_pos, norm_dist) %>%
group_by(participant) %>%
mutate(norm_hoop_pos = hoop_pos/max(hoop_pos)) %>%
ungroup() %>%
filter(norm_dist >= -1, norm_dist <= 1)# %>%
#  mutate(norm_dist2 = (norm_dist + 1)/2 - 1e-4)
model_data$norm_dist2[model_data$norm_dist2 == 1] <- 1-1e-5
model_data$norm_dist2[model_data$norm_dist == 1] <- 1-1e-5
m2 <- brm(norm_dist2 ~ norm_hoop_pos,
data = model_data,
family = "beta",
cores = 1,
chains = 1,
iter = 2000)
plt <- model_data %>%
add_predicted_draws(m2) %>%
ggplot(aes(.prediction)) +
geom_density() +
theme_minimal()
plt
View(model_data)
model_data <- norm_dat %>%
select(participant, hoop_pos, norm_dist) %>%
group_by(participant) %>%
mutate(norm_hoop_pos = hoop_pos/max(hoop_pos)) %>%
ungroup() %>%
filter(norm_dist >= -1, norm_dist <= 1)# %>%
#  mutate(norm_dist2 = (norm_dist + 1)/2 - 1e-4)
model_data$norm_dist2 <- model_data$norm_dist
model_data$norm_dist2[model_data$norm_dist == 1] <- 1-1e-5
View(model_data)
model_data <- norm_dat %>%
select(participant, hoop_pos, norm_dist) %>%
group_by(participant) %>%
mutate(norm_hoop_pos = hoop_pos/max(hoop_pos)) %>%
ungroup() %>%
filter(norm_dist >= -1, norm_dist <= 1)# %>%
mutate(norm_dist2 = (norm_dist + 1)/2)
model_data$norm_dist2[model_data$norm_dist2 == 1] <- 1-1e-5
View(model_data)
# sort out data for modelling?
model_data <- norm_dat %>%
select(participant, hoop_pos, norm_dist) %>%
group_by(participant) %>%
mutate(norm_hoop_pos = hoop_pos/max(hoop_pos)) %>%
ungroup() %>%
filter(norm_dist >= -1, norm_dist <= 1) %>%
mutate(norm_dist2 = (norm_dist + 1)/2)
model_data$norm_dist2[model_data$norm_dist2 == 1] <- 1-1e-5
View(model_data)
m2 <- brm(norm_dist2 ~ norm_hoop_pos,
data = model_data,
family = "beta",
cores = 1,
chains = 1,
iter = 2000)
plt <- model_data %>%
add_predicted_draws(m2) %>%
ggplot(aes(.prediction)) +
geom_density() +
theme_minimal()
plt
plt <- model_data %>%
add_predicted_draws(m2) %>%
ggplot(aes(.prediction)) +
geom_histogram() +
theme_minimal()
plt
mean(plt$data$.prediction)
sd(plt$data$.prediction)
model_data %>%
ggplot(aes(norm_dist)) +
geom_histogram()
model_data %>%
ggplot(aes(norm_dist)) +
geom_density()
m1 <- brm(norm_dist ~ norm_hoop_pos,
data = model_data,
family = "normal",
cores = 1,
chains = 1,
iter = 2000)
# plot posterior?
plt <- model_data %>%
add_predicted_draws(m1) %>%
ggplot(aes(.prediction)) +
geom_density() +
theme_minimal()
plt
