norm_dat$small_pos[q] <- norm_dat$small_pos[q] *-1
norm_dat$subject_position[q] <- norm_dat$subject_position[q]*-1
norm_dat$large_pos[q] <- norm_dat$large_pos[q]*-1
}
}
# tidy
rm(i, q, z)
# apply the normalising distance function
norm_dat$norm_dist <- norm_dist(norm_dat$subject_position, norm_dat$hoop_pos)
#### work out opt switching point ####
# create empty data.frame to get partcipants accuracy across all hoop separations
acc_slab <- data.frame(participant = character(),
hoop_size = character(),
slab = numeric(),
acc = numeric())
# create data.frame for just the switch point
switch_slab <- data.frame(participant = character(),
hoop_size = character(),
slab = numeric())
# set distances to be estimated
dist_seq <- seq(0,38,0.5)
for(x in unique(beanbagdat$participant))
{
for(i in unique(beanbagdat$hoop_size))
{
ss = beanbagdat[beanbagdat$participant==x & beanbagdat$hoop_size==i,]
m = glm(data=ss, cbind(inhoop, trials-inhoop)~slab+0,
offset=ss$off_set, binomial)
for(a in unique(dist_seq))
{
p = predict(m, data.frame(slab=a), type="response")
p = as.numeric(p)
acc_slab <- rbind(acc_slab, data.frame(participant = x,
hoop_size = i,
slab = a,
acc = round(p[1], digits = 7)))
}
slab = max(which(predict(m, data.frame(slab=dist_seq), type='response')>0.5))
b = dist_seq[slab]
switch_slab <- rbind(switch_slab, data.frame(participant = x,
hoop_size = i,
slab = b))
}
}
# tidy
rm(ss, m, a, i, p, x, b, slab, dist_seq)
# get switch points for small hoops
switch_slab_sm <- switch_slab[switch_slab$hoop_size == "small",]
switch_slab_sm <- switch_slab_sm[,c("participant",
"slab")]
colnames(switch_slab_sm) <- c("participant", "switchSlab_sm")
# now for large
switch_slab_la <- switch_slab[switch_slab$hoop_size == "large",]
switch_slab_la <- switch_slab_la[,c("participant",
"slab")]
colnames(switch_slab_la) <- c("participant", "switchSlab_la")
# get switch pos depending on average dist
# this is to reflect the point at which participants can't maintain
# an average acc of 50%
switch_slab_both <- merge(switch_slab_la, switch_slab_sm)
switch_slab_both$switchSlab <- (switch_slab_both$switchSlab_la +
switch_slab_both$switchSlab_sm)/2
switch_slab_both <- switch_slab_both[,c("participant", "switchSlab")]
# create switchSlab column in norm_dat
norm_dat <- merge(switch_slab_both, norm_dat)
# tidy
rm(switch_slab, switch_slab_la, switch_slab_sm, switch_slab_both)
#### get even acc stand dist ####
# get small distances first
temp_small <- melt(slabs_to_test[slabs_to_test$hoop_size == "small",],
id = c("participant", "hoop_size"))
temp_small <- temp_small[,c("participant",
"value")]
colnames(temp_small) <- c("participant",
"small_hoop_dist")
# now get avg dists
temp_avg <- melt(slabs_to_test[slabs_to_test$hoop_size == "avg",],
id = c("participant",
"hoop_size"))
temp_avg <- temp_avg[,c("participant",
"value")]
colnames(temp_avg) <- c("participant",
"avg_hoop_dist")
# tidy
rm(slabs_to_test)
# merge data sets
temp_avg_small <- cbind(temp_avg, temp_small)
temp_avg_small <- temp_avg_small[,c("participant",
"avg_hoop_dist",
"small_hoop_dist")]
colnames(temp_avg_small) <- c("participant",
"hoop_pos",
"small_hoop_dist")
# get the amount of shift towards the small hoop
temp_avg_small$shift <- temp_avg_small$hoop_pos - temp_avg_small$small_hoop_dist
# remove small_hoop_dist
temp_avg_small <- temp_avg_small[,c("participant",
"hoop_pos",
"shift")]
# add this into norm_dat
norm_dat <- merge(temp_avg_small, norm_dat)
# reorder columns so it's clearer
norm_dat <- norm_dat[,c("participant",
"trial",
"colour",
"direction",
"subject_position",
"accuracy",
"R",
"Y",
"B",
"B_N_Size",
"Y_N_Size",
"R_N_Size",
"hoop_pos",
"small_pos",
"large_pos",
"norm_dist",
"switchSlab",
"shift")]
# tidy
rm(temp_avg, temp_avg_small, temp_small)
#### get standing position for equal accuracy ####
norm_dat$equacc <- norm_dist(norm_dat$shift, norm_dat$hoop_pos)
#### add in opt standing position ####
norm_dat$optpos <- norm_dat$equacc
norm_dat$optpos[norm_dat$hoop_pos > norm_dat$switchSlab] <- 1
# add in metres column
norm_dat$metres <- norm_dat$hoop_pos*Hoop_size
#### make plot of opt swithing poing by standing position ####
# still need to calculate their opt standing positions
plt <- ggplot(norm_dat, aes(metres, norm_dist))
plt <- plt + geom_point(alpha = 0.3)
#plt <- plt + geom_jitter(width = 0.3, height = 0.0)
plt <- plt + theme_bw()
# plt <- plt + geom_line(aes(hoop_pos, equacc, colour = "Equal Accuracy"), size = 1.2, alpha = 0.7)
# plt <- plt + geom_line(aes(hoop_pos, optpos, colour = "Optimal"), size = 1.2, alpha = 0.7)
# plt <- plt + geom_point(aes(hoop_pos, optpos, colour = "Optimal"))
# plt <- plt + geom_point(aes(hoop_pos, equacc, colour = "Equal Accuracy"))
plt <- plt + geom_line(aes(metres, equacc,
colour = "Equal Accuracy"),
size = 1.2,
alpha = 0.7)
plt <- plt + geom_line(aes(metres, optpos,
colour = "Optimal"),
size = 1.2,
alpha = 0.7)
plt <- plt + geom_point(aes(metres, optpos,
colour = "Optimal"))
plt <- plt + geom_point(aes(metres, equacc,
colour = "Equal Accuracy"))
# plt <- plt + geom_vline(xintercept = norm_dat$switchSlab)
plt <- plt + scale_y_continuous(name="Normalised Participant Position", limits=c(-1,1))
plt <- plt + scale_x_continuous(name="Delta (Metres)" ,
limits= c(1.5, 10),
breaks = c(2,4,6,8,10))
plt <- plt + geom_hline(yintercept = 0)
plt <- plt + facet_wrap(~participant, ncol = 6)
plt <- plt + theme(legend.position = "bottom")
# Change legend title
plt$labels$colour <- "Line Type"
plt
plt <- plt + facet_wrap(~as.numeric(participant), ncol = 6)
plt
plt <- ggplot(norm_dat, aes(metres, norm_dist))
plt <- plt + geom_point(alpha = 0.3)
#plt <- plt + geom_jitter(width = 0.3, height = 0.0)
plt <- plt + theme_bw()
# plt <- plt + geom_line(aes(hoop_pos, equacc, colour = "Equal Accuracy"), size = 1.2, alpha = 0.7)
# plt <- plt + geom_line(aes(hoop_pos, optpos, colour = "Optimal"), size = 1.2, alpha = 0.7)
# plt <- plt + geom_point(aes(hoop_pos, optpos, colour = "Optimal"))
# plt <- plt + geom_point(aes(hoop_pos, equacc, colour = "Equal Accuracy"))
plt <- plt + geom_line(aes(metres, equacc,
colour = "Equal Accuracy"),
size = 1.2,
alpha = 0.7)
plt <- plt + geom_line(aes(metres, optpos,
colour = "Optimal"),
size = 1.2,
alpha = 0.7)
plt <- plt + geom_point(aes(metres, optpos,
colour = "Optimal"))
plt <- plt + geom_point(aes(metres, equacc,
colour = "Equal Accuracy"))
# plt <- plt + geom_vline(xintercept = norm_dat$switchSlab)
plt <- plt + scale_y_continuous(name="Normalised Participant Position", limits=c(-1,1))
plt <- plt + scale_x_continuous(name="Delta (Metres)" ,
limits= c(1.5, 10),
breaks = c(2,4,6,8,10))
plt <- plt + geom_hline(yintercept = 0)
plt <- plt + facet_wrap(~as.numeric(participant), ncol = 6)
plt <- plt + theme(legend.position = "bottom")
# Change legend title
plt$labels$colour <- "Line Type"
plt
# still need to calculate their opt standing positions
plt <- ggplot(norm_dat, aes(metres, norm_dist))
plt <- plt + geom_point(alpha = 0.3)
#plt <- plt + geom_jitter(width = 0.3, height = 0.0)
plt <- plt + theme_bw()
# plt <- plt + geom_line(aes(hoop_pos, equacc, colour = "Equal Accuracy"), size = 1.2, alpha = 0.7)
# plt <- plt + geom_line(aes(hoop_pos, optpos, colour = "Optimal"), size = 1.2, alpha = 0.7)
# plt <- plt + geom_point(aes(hoop_pos, optpos, colour = "Optimal"))
# plt <- plt + geom_point(aes(hoop_pos, equacc, colour = "Equal Accuracy"))
plt <- plt + geom_line(aes(metres, equacc,
colour = "Equal Accuracy"),
size = 1.2,
alpha = 0.7)
plt <- plt + geom_line(aes(metres, optpos,
colour = "Optimal"),
size = 1.2,
alpha = 0.7)
plt <- plt + geom_point(aes(metres, optpos,
colour = "Optimal"))
plt <- plt + geom_point(aes(metres, equacc,
colour = "Equal Accuracy"))
# plt <- plt + geom_vline(xintercept = norm_dat$switchSlab)
plt <- plt + scale_y_continuous(name="Normalised Participant Position", limits=c(-1,1))
plt <- plt + scale_x_continuous(name="Delta (Metres)" ,
limits= c(1.5, 10),
breaks = c(2,4,6,8,10))
plt <- plt + geom_hline(yintercept = 0)
plt <- plt + facet_wrap(~participant, ncol = 6)
plt <- plt + theme(legend.position = "bottom")
# Change legend title
plt$labels$colour <- "Line Type"
plt
str(norm_dat)
# still need to calculate their opt standing positions
plt <- ggplot(norm_dat, aes(metres, norm_dist))
plt <- plt + geom_point(alpha = 0.3)
#plt <- plt + geom_jitter(width = 0.3, height = 0.0)
plt <- plt + theme_bw()
# plt <- plt + geom_line(aes(hoop_pos, equacc, colour = "Equal Accuracy"), size = 1.2, alpha = 0.7)
# plt <- plt + geom_line(aes(hoop_pos, optpos, colour = "Optimal"), size = 1.2, alpha = 0.7)
# plt <- plt + geom_point(aes(hoop_pos, optpos, colour = "Optimal"))
# plt <- plt + geom_point(aes(hoop_pos, equacc, colour = "Equal Accuracy"))
plt <- plt + geom_line(aes(metres, equacc,
colour = "Equal Accuracy"),
size = 1.2,
alpha = 0.7)
plt <- plt + geom_line(aes(metres, optpos,
colour = "Optimal"),
size = 1.2,
alpha = 0.7)
plt <- plt + geom_point(aes(metres, optpos,
colour = "Optimal"))
plt <- plt + geom_point(aes(metres, equacc,
colour = "Equal Accuracy"))
# plt <- plt + geom_vline(xintercept = norm_dat$switchSlab)
plt <- plt + scale_y_continuous(name="Normalised Participant Position", limits=c(-1,1))
plt <- plt + scale_x_continuous(name="Delta (Metres)" ,
limits= c(1.5, 10),
breaks = c(2,4,6,8,10))
plt <- plt + geom_hline(yintercept = 0)
plt <- plt + facet_wrap(~as.numeric(participant), ncol = 6)
plt <- plt + theme(legend.position = "bottom")
# Change legend title
plt$labels$colour <- "Line Type"
plt
head(norm_data)
head(norm_dat)
rm(list = ls())
#### level 3 - 2nd Semester 2017/18 ####
# Part 2 Standing position script
# This script looks at where participants stood on each trial and
# also where they should have stood for the optimal strategy. Also,
# it looks at where they would have stood if they were trying to
# achieve equal accuracy for both hoop sizes.
# Written by Warren James
#### Load in the libraries ####
library(tidyverse)
library(reshape2)
#### Constants ####
Hoop_size <- 0.46
#### Created functions ####
# normalising distance function
norm_dist <- function(x,y){
2*(x - (y*-1))/(y - (y*-1))-1
}
#### read in the data ####
dat <- read.csv("data/Part_2/Part2_measures.txt", sep = "\t")
#### Pre-process data ####
# sort out participant coding
dat$participant <- paste(dat$experimenter, dat$participant, sep = "_")
dat$participant <- as.factor(dat$participant)
# drop experimenter column
dat <- dat[ , !(names(dat) %in% "experimenter")]
# make all colour values the same
# sort red
dat$colour[dat$colour == "Red"] <- "R"
# sort yellow
dat$colour[dat$colour == "y"] <- "Y"
dat$colour[dat$colour == " Y"] <- "Y"
dat$colour[dat$colour == "Y "] <- "Y"
dat$colour[dat$colour == "Y  "] <- "Y"
dat$colour[dat$colour == "Y   "] <- "Y"
dat$colour[dat$colour == "Yellow"] <- "Y"
dat$colour[dat$colour == "Yellow "] <- "Y"
dat$colour[dat$colour == "yellow"] <- "Y"
# sort blue
dat$colour[dat$colour == "Blue"] <- "B"
dat$colour[dat$colour == "Blue "] <- "B"
# unique order now B Y R
# remove unused levels
dat$colour <- factor(dat$colour)
# reorder levels
dat$colour <- factor(dat$colour,
levels(dat$colour)[c(1,3,2)])
# add in hoop_position
for (row in 1:nrow(dat))
{
dat$hoop_pos[row] = dat[row,as.character(dat$colour[row])]
}
# tidy
rm(row)
# create columns to fill
dat$small_pos <- 0
dat$large_pos <- 0
#### input small hoop pos ####
# rownames used so it doesn't loop over the first 15 rows...
for(i in levels(dat$participant)){
a <- 10
for(x in levels(dat$colour)){
for(z in rownames(dat[dat$colour == x & dat$participant == i,])){
q <- as.numeric(z)
if(unique(dat[q,a]) == "large"){
dat$small_pos[q] <- dat$hoop_pos[q]*-1
} else {
dat$small_pos[q] <-  dat$hoop_pos[q]
}
}
a <- a + 1
}
}
# tidy
rm(a,i,q,x,z)
# add in large pos
dat$large_pos <- dat$small_pos*-1
#### load in data from part 1 ####
# part1 acc measures
load("temp/beanbagdat")
# slabs to test
load("temp/slabs_to_test")
#### normalising distance data ####
# this means we need to make all large hoops negative and standing towards these negative values too
# Also, make small hoops positive, and the standing positions closer to small hoops
# Can do this based on position data; probably separate it out...
norm_dat <- dat
# can probably loop through it?
for(i in levels(norm_dat$participant)){
for(z in rownames(norm_dat[norm_dat$large_pos > 0 & norm_dat$participant == i,])){
q <- as.numeric(z)
norm_dat$small_pos[q] <- norm_dat$small_pos[q] *-1
norm_dat$subject_position[q] <- norm_dat$subject_position[q]*-1
norm_dat$large_pos[q] <- norm_dat$large_pos[q]*-1
}
}
# tidy
rm(i, q, z)
# apply the normalising distance function
norm_dat$norm_dist <- norm_dist(norm_dat$subject_position, norm_dat$hoop_pos)
#### work out opt switching point ####
# create empty data.frame to get partcipants accuracy across all hoop separations
acc_slab <- data.frame(participant = character(),
hoop_size = character(),
slab = numeric(),
acc = numeric())
# create data.frame for just the switch point
switch_slab <- data.frame(participant = character(),
hoop_size = character(),
slab = numeric())
# set distances to be estimated
dist_seq <- seq(0,38,0.5)
for(x in unique(beanbagdat$participant))
{
for(i in unique(beanbagdat$hoop_size))
{
ss = beanbagdat[beanbagdat$participant==x & beanbagdat$hoop_size==i,]
m = glm(data=ss, cbind(inhoop, trials-inhoop)~slab+0,
offset=ss$off_set, binomial)
for(a in unique(dist_seq))
{
p = predict(m, data.frame(slab=a), type="response")
p = as.numeric(p)
acc_slab <- rbind(acc_slab, data.frame(participant = x,
hoop_size = i,
slab = a,
acc = round(p[1], digits = 7)))
}
slab = max(which(predict(m, data.frame(slab=dist_seq), type='response')>0.5))
b = dist_seq[slab]
switch_slab <- rbind(switch_slab, data.frame(participant = x,
hoop_size = i,
slab = b))
}
}
# tidy
rm(ss, m, a, i, p, x, b, slab, dist_seq)
# get switch points for small hoops
switch_slab_sm <- switch_slab[switch_slab$hoop_size == "small",]
switch_slab_sm <- switch_slab_sm[,c("participant",
"slab")]
colnames(switch_slab_sm) <- c("participant", "switchSlab_sm")
# now for large
switch_slab_la <- switch_slab[switch_slab$hoop_size == "large",]
switch_slab_la <- switch_slab_la[,c("participant",
"slab")]
colnames(switch_slab_la) <- c("participant", "switchSlab_la")
# get switch pos depending on average dist
# this is to reflect the point at which participants can't maintain
# an average acc of 50%
switch_slab_both <- merge(switch_slab_la, switch_slab_sm)
switch_slab_both$switchSlab <- (switch_slab_both$switchSlab_la +
switch_slab_both$switchSlab_sm)/2
switch_slab_both <- switch_slab_both[,c("participant", "switchSlab")]
# create switchSlab column in norm_dat
norm_dat <- merge(switch_slab_both, norm_dat)
# tidy
rm(switch_slab, switch_slab_la, switch_slab_sm, switch_slab_both)
#### get even acc stand dist ####
# get small distances first
temp_small <- melt(slabs_to_test[slabs_to_test$hoop_size == "small",],
id = c("participant", "hoop_size"))
temp_small <- temp_small[,c("participant",
"value")]
colnames(temp_small) <- c("participant",
"small_hoop_dist")
# now get avg dists
temp_avg <- melt(slabs_to_test[slabs_to_test$hoop_size == "avg",],
id = c("participant",
"hoop_size"))
temp_avg <- temp_avg[,c("participant",
"value")]
colnames(temp_avg) <- c("participant",
"avg_hoop_dist")
# tidy
rm(slabs_to_test)
# merge data sets
temp_avg_small <- cbind(temp_avg, temp_small)
temp_avg_small <- temp_avg_small[,c("participant",
"avg_hoop_dist",
"small_hoop_dist")]
colnames(temp_avg_small) <- c("participant",
"hoop_pos",
"small_hoop_dist")
# get the amount of shift towards the small hoop
temp_avg_small$shift <- temp_avg_small$hoop_pos - temp_avg_small$small_hoop_dist
# remove small_hoop_dist
temp_avg_small <- temp_avg_small[,c("participant",
"hoop_pos",
"shift")]
# add this into norm_dat
norm_dat <- merge(temp_avg_small, norm_dat)
# reorder columns so it's clearer
norm_dat <- norm_dat[,c("participant",
"trial",
"colour",
"direction",
"subject_position",
"accuracy",
"R",
"Y",
"B",
"B_N_Size",
"Y_N_Size",
"R_N_Size",
"hoop_pos",
"small_pos",
"large_pos",
"norm_dist",
"switchSlab",
"shift")]
# tidy
rm(temp_avg, temp_avg_small, temp_small)
#### get standing position for equal accuracy ####
norm_dat$equacc <- norm_dist(norm_dat$shift, norm_dat$hoop_pos)
#### add in opt standing position ####
norm_dat$optpos <- norm_dat$equacc
norm_dat$optpos[norm_dat$hoop_pos > norm_dat$switchSlab] <- 1
# add in metres column
norm_dat$metres <- norm_dat$hoop_pos*Hoop_size
plt <- ggplot(norm_dat, aes(metres, norm_dist))
plt <- plt + geom_point(alpha = 0.3)
#plt <- plt + geom_jitter(width = 0.3, height = 0.0)
plt <- plt + theme_bw()
# plt <- plt + geom_line(aes(hoop_pos, equacc, colour = "Equal Accuracy"), size = 1.2, alpha = 0.7)
# plt <- plt + geom_line(aes(hoop_pos, optpos, colour = "Optimal"), size = 1.2, alpha = 0.7)
# plt <- plt + geom_point(aes(hoop_pos, optpos, colour = "Optimal"))
# plt <- plt + geom_point(aes(hoop_pos, equacc, colour = "Equal Accuracy"))
plt <- plt + geom_line(aes(metres, equacc,
colour = "Equal Accuracy"),
size = 1.2,
alpha = 0.7)
plt <- plt + geom_line(aes(metres, optpos,
colour = "Optimal"),
size = 1.2,
alpha = 0.7)
plt <- plt + geom_point(aes(metres, optpos,
colour = "Optimal"))
plt <- plt + geom_point(aes(metres, equacc,
colour = "Equal Accuracy"))
# plt <- plt + geom_vline(xintercept = norm_dat$switchSlab)
plt <- plt + scale_y_continuous(name="Normalised Participant Position", limits=c(-1,1))
plt <- plt + scale_x_continuous(name="Delta (Metres)" ,
limits= c(1.5, 10),
breaks = c(2,4,6,8,10))
plt <- plt + geom_hline(yintercept = 0)
plt
metres
plt <- plt + facet_wrap(~as.numeric(participant), ncol = 6)
plt
