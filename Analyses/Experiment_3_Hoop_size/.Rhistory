#### Make plots of just centre vs side by condition ####
# add in centre vs side column
prop_sides$cen_sid <- "Side"
prop_sides$cen_sid[prop_sides$prop_boxes == 0] <- "Centre"
# get summary
cen_side <- prop_sides %>%
group_by(participant, separation, bias_type, cen_sid) %>%
summarise(n = sum(n)) %>%
mutate(prop = n / sum(n))
cen_side <- merge(cen_side, switch_points)
# make the plots like the rest
centre <- cen_side[cen_side$cen_sid == "Centre",]
side <- cen_side[cen_side$cen_sid == "Side",]
dot_plt <- ggplot(side, aes(get_VisDegs(separation/ppcm, Screen_dist),
prop,
colour = bias_type))
dot_plt <- dot_plt + geom_point(aes(shape = bias_type,
colour = bias_type)) +
scale_shape_manual(values=c(3,4))
# make 80_20 switch
dot_plt <- dot_plt + geom_vline(aes(xintercept = get_VisDegs(Eighty_Twenty/ppcm, Screen_dist)),
linetype = "dashed",
colour = "red")
# make 50_50 switch
dot_plt <- dot_plt + geom_vline(aes(xintercept = get_VisDegs(Fifty_Fifty/ppcm, Screen_dist)),
linetype = "dashed",
colour = "blue")
dot_plt <- dot_plt + facet_wrap(~participant)
dot_plt <- dot_plt + theme(legend.position="bottom")
dot_plt$labels$y <- "Proportion of Fixations to the side boxes"
dot_plt$labels$x <- "Delta (Visual Degrees)"
dot_plt$labels$colour <- "Bias Type"
dot_plt$labels$shape <- "Bias Type"
dot_plt
# save this
# ggsave("scratch/plots/SideVSCentre.pdf", height = 10, width = 10)
#### Get bias to one side ####
# so make it so 0 means no bias (both equal) and one means exclusively one or the other?
df_just_side <- df[df$lcr != 0,]
bias_sides <- df_just_side %>%
group_by(participant, bias_type, lcr) %>%
summarise(num = n()) %>%
mutate(prop = num/sum(num))
bias_sides_2 <- bias_sides[-c(4)] %>%
group_by(participant) %>%
spread(lcr, prop)
bias_sides_2[is.na(bias_sides_2)] <- 0
# these give the exact same results
bias_sides_2$score <- abs(bias_sides_2$`1` - bias_sides_2$`-1`)
bias_sides_2$highest <- pmax(bias_sides_2$`1`, bias_sides_2$`-1`)
bias_sides_2$lowest <- pmin(bias_sides_2$`1`, bias_sides_2$`-1`)
# make it a factor
bias_sides_2$participant <- as.factor(bias_sides_2$participant)
bias_sides_2$bias_type <- as.factor(bias_sides_2$bias_type)
# really simple t test of these results
ttest <- t.test(bias_sides_2$score~bias_sides_2$bias_type, paired = T)
ttest
# fix it for proportions...
bias_sides_3 <- bias_sides[-c(5)] %>%
group_by(participant) %>%
spread(lcr, num)
bias_sides_3[is.na(bias_sides_3)] <- 0
bias_sides_3$highest <- pmax(bias_sides_3$`1`, bias_sides_3$`-1`)
bias_sides_3$lowest <- pmin(bias_sides_3$`1`, bias_sides_3$`-1`)
temp_data <- matrix(c(mean(bias_sides_3$highest[bias_sides_3$bias_type == "biased"]),
mean(bias_sides_3$highest[bias_sides_3$bias_type == "random"]),
mean(bias_sides_3$lowest[bias_sides_3$bias_type == "biased"]),
mean(bias_sides_3$lowest[bias_sides_3$bias_type == "random"])),
ncol = 2)
colnames(temp_data) <- c("highest", "lowest")
rownames(temp_data) <- c("biased", "random")
# all these show that they are significant... Maybe
# ask Alasdair about it?
prop.test(temp_data)
chisq.test(temp_data)
mcnemar.test(temp_data)
# temp <- glm(highest ~ bias_type,
#             data = bias_sides_2,
#             family = binomial())
# this is significant so get some descriptives
descs_bias <- bias_sides_2 %>%
group_by(bias_type) %>%
summarise(meanshigh = mean(highest),
sdshigh = sd(highest),
meanscore = mean(score),
sdscore = sd(score))
# remove person 5 to test this again.
desc_minus5 <- bias_sides_2[bias_sides_2$participant != "5",] %>%
group_by(bias_type) %>%
summarise(means = mean(highest))
#### Some GLM stuff ####
# Just so we have some numbers to write in... even though
# it's not really the best idea to do this
# model with no condition/bias_type
m1 <- glm(prop ~ separation,
data = side,
family = binomial())
summary(m1)
m2 <- glm(prop ~ separation + as.factor(bias_type),
data = side,
family = binomial())
summary(m2)
# Neither of these is significant which suggests that on average participants did not
# modify their fixations with relation to separation and there was no improvement
# when adding in condition... (this is easily told by looking at the plots though)
# what about just condition?
m3 <- glm(prop ~ as.factor(bias_type),
data = side,
family = binomial)
summary(m3)
# We could also try looking at whether people were sensitive to the bias side
# Maybe by getting a value for how much more often they looked at the "biased"
# side in both conditions?
#### NEW GLMR stuff ####
# spoke to Alasdair and he thinks this is the best approach
# need a subset of the data
glm_dat <- select(df_just_side,
participant,
bias,
block,
trial,
separation,
cross_side,
bias_type,
lcr,
standard_boxes)
glm_dat$fixated_left <- 0
glm_dat$fixated_left[glm_dat$lcr == -1] <- 1
glm_dat$fixated_common <- 0
glm_dat$fixated_common[glm_dat$standard_boxes == "most likely"] <- 1
glm_dat$bias_box_left <- 0
glm_dat$bias_box_left[glm_dat$bias == "left bias"] <- 1
# make bias_type a factor
glm_dat$bias_type <- as.factor(glm_dat$bias_type)
glm_dat$bias_box_left <- as.factor(glm_dat$bias_box_left)
m4 <- glmer(fixated_common ~ bias_type + (1 + bias_type|participant),
data = glm_dat,
family = binomial())
summary(m4)
m4 <- glmer(fixated_common ~ bias_type + (1|participant),
data = glm_dat,
family = binomial())
summary(m4)
m4.1 <- glmer(fixated_commone ~ bias_type + (1 + bias_type|participant),
data = glm_dat,
family = binomial())
summary(m4.1)
m4.1 <- glmer(fixated_common ~ bias_type + (1 + bias_type|participant),
data = glm_dat,
family = binomial())
summary(m4.1)
rm(list = ls())
setwd("E:/Github/Breaking_symmetry/Analyses/Experiment_3_Hoop_size")
#### level 3 - 2nd Semester 2017/18 ####
# Part 2 Standing position script
# This script looks at where participants stood on each trial and
# also where they should have stood for the optimal strategy. Also,
# it looks at where they would have stood if they were trying to
# achieve equal accuracy for both hoop sizes.
# Written by Warren James
#### Load in the libraries ####
library(tidyverse)
library(reshape2)
library(lme4)
#### Constants ####
Hoop_size <- 0.46
#### Created functions ####
# normalising distance function
norm_dist <- function(x,y){
2*(x - (y*-1))/(y - (y*-1))-1
}
#### read in the data ####
dat <- read.csv("data/Part_2/Part2_measures.txt", sep = "\t")
#### Pre-process data ####
# sort out participant coding
dat$participant <- paste(dat$experimenter, dat$participant, sep = "_")
dat$participant <- as.factor(dat$participant)
# drop experimenter column
dat <- dat[ , !(names(dat) %in% "experimenter")]
# make all colour values the same
# sort red
dat$colour[dat$colour == "Red"] <- "R"
# sort yellow
dat$colour[dat$colour == "y"] <- "Y"
dat$colour[dat$colour == " Y"] <- "Y"
dat$colour[dat$colour == "Y "] <- "Y"
dat$colour[dat$colour == "Y  "] <- "Y"
dat$colour[dat$colour == "Y   "] <- "Y"
dat$colour[dat$colour == "Yellow"] <- "Y"
dat$colour[dat$colour == "Yellow "] <- "Y"
dat$colour[dat$colour == "yellow"] <- "Y"
# sort blue
dat$colour[dat$colour == "Blue"] <- "B"
dat$colour[dat$colour == "Blue "] <- "B"
# unique order now B Y R
# remove unused levels
dat$colour <- factor(dat$colour)
# reorder levels
dat$colour <- factor(dat$colour,
levels(dat$colour)[c(1,3,2)])
# add in hoop_position
for (row in 1:nrow(dat))
{
dat$hoop_pos[row] = dat[row,as.character(dat$colour[row])]
}
# tidy
rm(row)
# create columns to fill
dat$small_pos <- 0
dat$large_pos <- 0
#### input small hoop pos ####
# rownames used so it doesn't loop over the first 15 rows...
for(i in levels(dat$participant)){
a <- 10
for(x in levels(dat$colour)){
for(z in rownames(dat[dat$colour == x & dat$participant == i,])){
q <- as.numeric(z)
if(unique(dat[q,a]) == "large"){
dat$small_pos[q] <- dat$hoop_pos[q]*-1
} else {
dat$small_pos[q] <-  dat$hoop_pos[q]
}
}
a <- a + 1
}
}
# tidy
rm(a,i,q,x,z)
# add in large pos
dat$large_pos <- dat$small_pos*-1
#### load in data from part 1 ####
# part1 acc measures
load("temp/beanbagdat")
# slabs to test
load("temp/slabs_to_test")
#### normalising distance data ####
# this means we need to make all large hoops negative and standing towards these negative values too
# Also, make small hoops positive, and the standing positions closer to small hoops
# Can do this based on position data; probably separate it out...
norm_dat <- dat
# can probably loop through it?
for(i in levels(norm_dat$participant)){
for(z in rownames(norm_dat[norm_dat$large_pos > 0 & norm_dat$participant == i,])){
q <- as.numeric(z)
norm_dat$small_pos[q] <- norm_dat$small_pos[q] *-1
norm_dat$subject_position[q] <- norm_dat$subject_position[q]*-1
norm_dat$large_pos[q] <- norm_dat$large_pos[q]*-1
}
}
# tidy
rm(i, q, z)
# apply the normalising distance function
norm_dat$norm_dist <- norm_dist(norm_dat$subject_position, norm_dat$hoop_pos)
#### work out opt switching point ####
# create empty data.frame to get partcipants accuracy across all hoop separations
acc_slab <- data.frame(participant = character(),
hoop_size = character(),
slab = numeric(),
acc = numeric())
# create data.frame for just the switch point
switch_slab <- data.frame(participant = character(),
hoop_size = character(),
slab = numeric())
# set distances to be estimated
dist_seq <- seq(0,38,0.5)
for(x in unique(beanbagdat$participant))
{
for(i in unique(beanbagdat$hoop_size))
{
ss = beanbagdat[beanbagdat$participant==x & beanbagdat$hoop_size==i,]
m = glm(data=ss, cbind(inhoop, trials-inhoop)~slab+0,
offset=ss$off_set, binomial)
for(a in unique(dist_seq))
{
p = predict(m, data.frame(slab=a), type="response")
p = as.numeric(p)
acc_slab <- rbind(acc_slab, data.frame(participant = x,
hoop_size = i,
slab = a,
acc = round(p[1], digits = 7)))
}
slab = max(which(predict(m, data.frame(slab=dist_seq), type='response')>0.5))
b = dist_seq[slab]
switch_slab <- rbind(switch_slab, data.frame(participant = x,
hoop_size = i,
slab = b))
}
}
# tidy
rm(ss, m, a, i, p, x, b, slab, dist_seq)
# get switch points for small hoops
switch_slab_sm <- switch_slab[switch_slab$hoop_size == "small",]
switch_slab_sm <- switch_slab_sm[,c("participant",
"slab")]
colnames(switch_slab_sm) <- c("participant", "switchSlab_sm")
# now for large
switch_slab_la <- switch_slab[switch_slab$hoop_size == "large",]
switch_slab_la <- switch_slab_la[,c("participant",
"slab")]
colnames(switch_slab_la) <- c("participant", "switchSlab_la")
# get switch pos depending on average dist
# this is to reflect the point at which participants can't maintain
# an average acc of 50%
switch_slab_both <- merge(switch_slab_la, switch_slab_sm)
switch_slab_both$switchSlab <- (switch_slab_both$switchSlab_la +
switch_slab_both$switchSlab_sm)/2
switch_slab_both <- switch_slab_both[,c("participant", "switchSlab")]
# create switchSlab column in norm_dat
norm_dat <- merge(switch_slab_both, norm_dat)
# tidy
rm(switch_slab, switch_slab_la, switch_slab_sm, switch_slab_both)
#### get even acc stand dist ####
# get small distances first
temp_small <- melt(slabs_to_test[slabs_to_test$hoop_size == "small",],
id = c("participant", "hoop_size"))
temp_small <- temp_small[,c("participant",
"value")]
colnames(temp_small) <- c("participant",
"small_hoop_dist")
# now get avg dists
temp_avg <- melt(slabs_to_test[slabs_to_test$hoop_size == "avg",],
id = c("participant",
"hoop_size"))
temp_avg <- temp_avg[,c("participant",
"value")]
colnames(temp_avg) <- c("participant",
"avg_hoop_dist")
# tidy
rm(slabs_to_test)
# merge data sets
temp_avg_small <- cbind(temp_avg, temp_small)
temp_avg_small <- temp_avg_small[,c("participant",
"avg_hoop_dist",
"small_hoop_dist")]
colnames(temp_avg_small) <- c("participant",
"hoop_pos",
"small_hoop_dist")
# get the amount of shift towards the small hoop
temp_avg_small$shift <- temp_avg_small$hoop_pos - temp_avg_small$small_hoop_dist
# remove small_hoop_dist
temp_avg_small <- temp_avg_small[,c("participant",
"hoop_pos",
"shift")]
# add this into norm_dat
norm_dat <- merge(temp_avg_small, norm_dat)
# reorder columns so it's clearer
norm_dat <- norm_dat[,c("participant",
"trial",
"colour",
"direction",
"subject_position",
"accuracy",
"R",
"Y",
"B",
"B_N_Size",
"Y_N_Size",
"R_N_Size",
"hoop_pos",
"small_pos",
"large_pos",
"norm_dist",
"switchSlab",
"shift")]
# tidy
rm(temp_avg, temp_avg_small, temp_small)
#### get standing position for equal accuracy ####
norm_dat$equacc <- norm_dist(norm_dat$shift, norm_dat$hoop_pos)
#### add in opt standing position ####
norm_dat$optpos <- norm_dat$equacc
norm_dat$optpos[norm_dat$hoop_pos > norm_dat$switchSlab] <- 1
# add in metres column
norm_dat$metres <- norm_dat$hoop_pos*Hoop_size
#### make plot of opt swithing poing by standing position ####
# still need to calculate their opt standing positions
temp_plt_dat <- norm_dat
temp_plt_dat$participant <- as.numeric(temp_plt_dat$participant)
plt <- ggplot(temp_plt_dat, aes(metres, norm_dist))
plt <- plt + geom_point(alpha = 0.3)
#plt <- plt + geom_jitter(width = 0.3, height = 0.0)
plt <- plt + theme_bw()
# plt <- plt + geom_line(aes(hoop_pos, equacc, colour = "Equal Accuracy"), size = 1.2, alpha = 0.7)
# plt <- plt + geom_line(aes(hoop_pos, optpos, colour = "Optimal"), size = 1.2, alpha = 0.7)
# plt <- plt + geom_point(aes(hoop_pos, optpos, colour = "Optimal"))
# plt <- plt + geom_point(aes(hoop_pos, equacc, colour = "Equal Accuracy"))
plt <- plt + geom_line(aes(metres, equacc,
colour = "Equal Accuracy"),
size = 1.2,
alpha = 0.7)
plt <- plt + geom_line(aes(metres, optpos,
colour = "Optimal"),
size = 1.2,
alpha = 0.7)
plt <- plt + geom_point(aes(metres, optpos,
colour = "Optimal"))
plt <- plt + geom_point(aes(metres, equacc,
colour = "Equal Accuracy"))
# plt <- plt + geom_vline(xintercept = norm_dat$switchSlab)
plt <- plt + scale_y_continuous(name="Normalised Participant Position", limits=c(-1,1))
plt <- plt + scale_x_continuous(name="Delta (Metres)" ,
limits= c(1.5, 10),
breaks = c(2,4,6,8,10))
plt <- plt + geom_hline(yintercept = 0)
plt <- plt + facet_wrap(~participant, ncol = 6)
plt <- plt + theme(legend.position = "bottom")
# Change legend title
plt$labels$colour <- "Line Type"
plt
#### save plot to figures folder ####
# ggsave("../../Figures/Experiment_3_Hoop_size/Session_2_plot.png",
#        width = 18,
#        height = 16,
#        units = "cm")
# tidy
rm(plt, temp_plt_dat)
#### proportion of standing positions ####
norm_dat$prop_sizes <- 0
norm_dat$prop_sizes[norm_dat$subject_position > 0] <- 1
norm_dat$prop_sizes[norm_dat$subject_position < 0] <- (-1)
# get summary of this for each participant and distance
# create df for this
prop_sides <- data.frame(participant = character(),
hoop_pos = numeric(),
prop_sizes = numeric(),
prop = numeric(),
count = numeric())
for(i in unique(norm_dat$participant)){
for(x in unique(norm_dat$hoop_pos[norm_dat$participant == i])){
for(z in unique(norm_dat$prop_sizes)){
temp_num <- (nrow(norm_dat[norm_dat$participant == i &
norm_dat$hoop_pos == x,]))
prop <- (nrow(norm_dat[norm_dat$participant == i &
norm_dat$hoop_pos == x &
norm_dat$prop_sizes == z,])/temp_num)
count <- nrow(norm_dat[norm_dat$participant == i &
norm_dat$hoop_pos == x &
norm_dat$prop_sizes == z,])
prop_sides <- rbind(prop_sides, data.frame(participant = i,
hoop_pos = x,
prop_sizes = z,
prop = prop,
count = count))
}
}
}
# tidy
rm(count, i, prop, temp_num, x, z)
prop_sides$prop_sizes <- as.factor(prop_sides$prop_sizes)
prop_sides$stpos_type <- "Centre"
prop_sides$stpos_type[prop_sides$prop_sizes == "-1"] <- "Large Hoop"
prop_sides$stpos_type[prop_sides$prop_sizes == "1"] <- "Small Hoop"
prop_sides$metres <- prop_sides$hoop_pos*Hoop_size
prop_sides$participant <- as.numeric(prop_sides$participant)
#### Make the proportion plot ####
prop_plt <- ggplot(data = prop_sides,
aes(x = metres,
y = prop))
prop_plt <- prop_plt + theme_bw()
prop_plt <- prop_plt + geom_area(aes(colour = stpos_type,
fill = stpos_type),
position = "stack")
prop_plt <- prop_plt + scale_y_continuous(name="Normalised Participant Position",
limits=c(0,1))
prop_plt <- prop_plt + scale_x_continuous(name="Delta (Metres)",
limits= c(1.5, 10),
breaks = c(2,4,6,8,10))
prop_plt <- prop_plt + theme(legend.position = "bottom")
# prop_plt <- prop_plt + scale_fill_discrete(breaks = c("Large Hoop",
#                                                       "Centre",
#                                                       "Small Hoop"))
# prop_plt <- prop_plt + scale_color_discrete(breaks = c("Large Hoop",
#                                                        "Centre",
#                                                        "Small Hoop"))
#prop_plt <- prop_plt + geom_vline(data = switch_points,
#                                  aes(xintercept = as.numeric(switch_point)),
#                                  linetype = "dashed")
prop_plt <- prop_plt + facet_wrap(~participant, ncol = 6)
prop_plt$labels$colour <- "Stood Towards"
prop_plt$labels$fill <- "Stood Towards"
# Draw plot
prop_plt
# Save plot
# ggsave("../../Figures/Experiment_3_Hoop_size/Session_2_proportions.png",
#        width = 18,
#        height = 16,
#        units = "cm")
#### get t-test results to look at proportions ####
# sort out the data frame for this
bias_sides <- prop_sides[prop_sides$stpos_type != "Centre",]
bias_sides_2 <- bias_sides %>%
group_by(participant, stpos_type) %>%
summarise(total = sum(count)) %>%
mutate(prop = total/sum(total))
# now do some tests I think...
t.test(prop ~ stpos_type, data = bias_sides_2)
# shows it significant
# but this is a bad way to do it and you know that....
#### GLMER time bois and girls ####
# setup the data
glm_dat <- dat[dat$subject_position != 0,]
# now get if they were closer to the small hoop or not
glm_dat$small_hoop_left <- 0
glm_dat$small_hoop_left[glm_dat$small_pos < 0] <- 1
glm_dat$subj_left <- 0
glm_dat$subj_left[glm_dat$subject_position < 0] <- 1
# sort out factors
glm_dat$small_hoop_left <- as.factor(glm_dat$small_hoop_left)
m1 <- glmer(subj_left ~ small_hoop_left + (1|participant),
family = binomial(),
data = glm_dat)
summary(m1)
View(glm_dat)
