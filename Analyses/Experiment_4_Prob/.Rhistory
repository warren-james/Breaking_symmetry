install.packages(c("backports", "bayesplot", "BH", "bindr", "bindrcpp", "brms", "Brobdingnag", "broom", "callr", "caTools", "clipr", "curl", "DBI", "dbplyr", "devtools", "digest", "dplyr", "DT", "dygraphs", "evaluate", "forcats", "ggplot2", "ggthemes", "git2r", "glue", "gtools", "haven", "highr", "hms", "htmlwidgets", "httpuv", "igraph", "inline", "installr", "knitr", "lme4", "loo", "lubridate", "matrixStats", "miniUI", "modelr", "munsell", "mvtnorm", "nleqslv", "openssl", "packrat", "plogr", "psych", "purrr", "R.oo", "Rcpp", "RcppEigen", "RCurl", "readxl", "reprex", "reshape2", "rlang", "rmarkdown", "rprojroot", "rsconnect", "rstan", "rstantools", "selectr", "shiny", "shinystan", "sourcetools", "StanHeaders", "stringi", "stringr", "tibble", "tidyr", "tidyselect", "viridisLite", "withr", "xml2", "xts", "yaml", "zoo"))
install.packages(c("backports", "bayesplot", "BH", "bindr", "bindrcpp", "brms", "Brobdingnag", "broom", "callr", "caTools", "clipr", "curl", "DBI", "dbplyr", "devtools", "digest", "dplyr", "DT", "dygraphs", "evaluate", "forcats", "ggplot2", "ggthemes", "git2r", "glue", "gtools", "haven", "highr", "hms", "htmlwidgets", "httpuv", "igraph", "inline", "installr", "knitr", "lme4", "loo", "lubridate", "matrixStats", "miniUI", "modelr", "munsell", "mvtnorm", "nleqslv", "openssl", "packrat", "plogr", "psych", "purrr", "R.oo", "Rcpp", "RcppEigen", "RCurl", "readxl", "reprex", "reshape2", "rlang", "rmarkdown", "rprojroot", "rsconnect", "rstan", "rstantools", "selectr", "shiny", "shinystan", "sourcetools", "StanHeaders", "stringi", "stringr", "tibble", "tidyr", "tidyselect", "viridisLite", "withr", "xml2", "xts", "yaml", "zoo"))
install.packages(c("backports", "bayesplot", "BH", "bindr", "bindrcpp", "brms", "Brobdingnag", "broom", "callr", "caTools", "clipr", "curl", "DBI", "dbplyr", "devtools", "digest", "dplyr", "DT", "dygraphs", "evaluate", "forcats", "ggplot2", "ggthemes", "git2r", "glue", "gtools", "haven", "highr", "hms", "htmlwidgets", "httpuv", "igraph", "inline", "installr", "knitr", "lme4", "loo", "lubridate", "matrixStats", "miniUI", "modelr", "munsell", "mvtnorm", "nleqslv", "openssl", "packrat", "plogr", "psych", "purrr", "R.oo", "Rcpp", "RcppEigen", "RCurl", "readxl", "reprex", "reshape2", "rlang", "rmarkdown", "rprojroot", "rsconnect", "rstan", "rstantools", "selectr", "shiny", "shinystan", "sourcetools", "StanHeaders", "stringi", "stringr", "tibble", "tidyr", "tidyselect", "viridisLite", "withr", "xml2", "xts", "yaml", "zoo"))
install.packages(c("backports", "bayesplot", "BH", "bindr", "bindrcpp", "brms", "Brobdingnag", "broom", "callr", "caTools", "clipr", "curl", "DBI", "dbplyr", "devtools", "digest", "dplyr", "DT", "dygraphs", "evaluate", "forcats", "ggplot2", "ggthemes", "git2r", "glue", "gtools", "haven", "highr", "hms", "htmlwidgets", "httpuv", "igraph", "inline", "installr", "knitr", "lme4", "loo", "lubridate", "matrixStats", "miniUI", "modelr", "munsell", "mvtnorm", "nleqslv", "openssl", "packrat", "plogr", "psych", "purrr", "R.oo", "Rcpp", "RcppEigen", "RCurl", "readxl", "reprex", "reshape2", "rlang", "rmarkdown", "rprojroot", "rsconnect", "rstan", "rstantools", "selectr", "shiny", "shinystan", "sourcetools", "StanHeaders", "stringi", "stringr", "tibble", "tidyr", "tidyselect", "viridisLite", "withr", "xml2", "xts", "yaml", "zoo"))
library(tidyverse)
library(rethinking)
# simulate some proportion data
dat <- data.frame(x = rbeta(100, 3, 1.8))
# fit Beta distributon to data
m <- map2stan(
alist(
x ~ dbeta(shape1, shape2),
shape1 ~ dcauchy(0,1),
shape2 ~ dcauchy(0,1)),
data = dat)
summary(m)
n_samples = 100
post <- extract.samples(m, n_samples)
x <- seq(0,1, 0.01)
y <- dbeta(seq(0,1, 0.01), shape1 = 2, shape2 = 2)
p <- unlist(map2(post$shape1, post$shape2, dbeta, x  = x ))
n <- rep(1:n_samples, each = length(x))
fits <- tibble(x = rep(x, n_samples), p , n = n)
post <- extract.samples(m)
mu <- HPDI(with(post, shape1 / (shape1 + shape2), prob = 0.99))
plt <- ggplot()
plt <- plt + geom_density(data = dat,aes(x = dat$x), fill = "#ec9844", colour = "#ec9844", adjust = 1/2)
plt <- plt + geom_rect(aes(xmin = mu[1], xmax = mu[2], ymin = 0, ymax = Inf), fill = "blue", alpha = 0.3)
plt <- plt + geom_path(data = fits, aes(x = x, y = p, group = n), alpha = 0.1, size = 1)
plt <- plt + scale_x_continuous("proporiton", expand = c(0,0))
plt <- plt + scale_y_continuous("density", expand = c(0,0), limits = c(0, 2))
plt <- plt + theme_bw()
plt
n = 1000
dat <- data.frame(
x = c(rbeta(n, 3, 2), rbeta(n, 1, 2)),
z = rep(0:1, each = n))
plt <- ggplot(dat)
plt <- plt + geom_density(
aes(x = dat$x, fill = as.factor(dat$z)), adjust = 1/2)
plt
head(dat)
setwd("~/")
setwd("E:/Github/Breaking_symmetry/Analyses/Experiment_3_Hoop_size")
#### Modelling and plotting Hoop Size ####
#
#### Library ####
library(brms)
library(rstan)
library(tidybayes)
library(tidyverse)
#### Constants ####
Hoop_size <- 0.46
#### Functions ####
#### Load in data ####
load("scratch/df_part2_norm")
# sort out data for modelling?
model_data <- norm_dat %>%
select(participant, hoop_pos, norm_dist) %>%
group_by(participant) %>%
mutate(norm_hoop_pos = hoop_pos/max(hoop_pos)) %>%
ungroup() %>%
filter(norm_dist >= -1, norm_dist <= 1) %>%
mutate(norm_dist2 = (norm_dist + 1)/2)
model_data$norm_dist2[model_data$norm_dist2 == 1] <- 1-1e-5
# Should we model this as a beta dist and make centre <- 0.5?
#### Quick Plots ####
# density plot
model_data %>%
ggplot(aes(norm_dist)) +
geom_density()
head(norm_dat)
dir()
dir("data")
temp <- read.csv("data/Part_2/Part2_measures.txt", sep = "t\")
)
"
)
temp <- read.csv("data/Part_2/Part2_measures.txt", sep = "\t")
View(temp)
model_data_2 <- read.csv("data/Part_2/Part2_measures.txt", sep = "\t")
rm(temp)
head(model_dat_2)
head(model_data_2)
model_data_2 <- read.csv("data/Part_2/Part2_measures.txt", sep = "\t") %>%
filter(subject_position != 0)
head(model_data)
model_data_2 <- read.csv("data/Part_2/Part2_measures.txt", sep = "\t") %>%
filter(subject_position != 0) %>%
unite("participant",
c("experimenter", "participant"),
sep = "_")
View(model_data_2)
head(model_data_2)
rm(list = ls())
#### level 3 - 2nd Semester 2017/18 ####
# Part 2 Standing position script
# This script looks at where participants stood on each trial and
# also where they should have stood for the optimal strategy. Also,
# it looks at where they would have stood if they were trying to
# achieve equal accuracy for both hoop sizes.
# Written by Warren James
#### Load in the libraries ####
library(tidyverse)
library(reshape2)
library(lme4)
#### Constants ####
Hoop_size <- 0.46
#### Created functions ####
# normalising distance function
norm_dist <- function(x,y){
2*(x - (y*-1))/(y - (y*-1))-1
}
#### read in the data ####
dat <- read.csv("data/Part_2/Part2_measures.txt", sep = "\t")
#### Pre-process data ####
# sort out participant coding
dat$participant <- paste(dat$experimenter, dat$participant, sep = "_")
dat$participant <- as.factor(dat$participant)
# drop experimenter column
dat <- dat[ , !(names(dat) %in% "experimenter")]
# make all colour values the same
# sort red
dat$colour[dat$colour == "Red"] <- "R"
# sort yellow
dat$colour[dat$colour == "y"] <- "Y"
dat$colour[dat$colour == " Y"] <- "Y"
dat$colour[dat$colour == "Y "] <- "Y"
dat$colour[dat$colour == "Y  "] <- "Y"
dat$colour[dat$colour == "Y   "] <- "Y"
dat$colour[dat$colour == "Yellow"] <- "Y"
dat$colour[dat$colour == "Yellow "] <- "Y"
dat$colour[dat$colour == "yellow"] <- "Y"
# sort blue
dat$colour[dat$colour == "Blue"] <- "B"
dat$colour[dat$colour == "Blue "] <- "B"
# unique order now B Y R
# remove unused levels
dat$colour <- factor(dat$colour)
# reorder levels
dat$colour <- factor(dat$colour,
levels(dat$colour)[c(1,3,2)])
# add in hoop_position
for (row in 1:nrow(dat))
{
dat$hoop_pos[row] = dat[row,as.character(dat$colour[row])]
}
# tidy
rm(row)
# create columns to fill
dat$small_pos <- 0
dat$large_pos <- 0
#### input small hoop pos ####
# rownames used so it doesn't loop over the first 15 rows...
for(i in levels(dat$participant)){
a <- 10
for(x in levels(dat$colour)){
for(z in rownames(dat[dat$colour == x & dat$participant == i,])){
q <- as.numeric(z)
if(unique(dat[q,a]) == "large"){
dat$small_pos[q] <- dat$hoop_pos[q]*-1
} else {
dat$small_pos[q] <-  dat$hoop_pos[q]
}
}
a <- a + 1
}
}
# tidy
rm(a,i,q,x,z)
# add in large pos
dat$large_pos <- dat$small_pos*-1
#### load in data from part 1 ####
# part1 acc measures
load("temp/beanbagdat")
# slabs to test
load("temp/slabs_to_test")
head(dat)
save(dat, "scratch/df_part2_raw")
save(dat, file = "scratch/df_part2_raw")
rm(list = ls())
#### Modelling and plotting Hoop Size ####
#
#### Library ####
library(brms)
library(rstan)
library(tidybayes)
library(tidyverse)
#### Constants ####
Hoop_size <- 0.46
#### Functions ####
#### Load in data ####
load("scratch/df_part2_norm")
# sort out data for modelling?
model_data <- norm_dat %>%
select(participant, hoop_pos, norm_dist) %>%
group_by(participant) %>%
mutate(norm_hoop_pos = hoop_pos/max(hoop_pos)) %>%
ungroup() %>%
filter(norm_dist >= -1, norm_dist <= 1) %>%
mutate(norm_dist2 = (norm_dist + 1)/2)
model_data$norm_dist2[model_data$norm_dist2 == 1] <- 1-1e-5
# Should we model this as a beta dist and make centre <- 0.5?
#### Quick Plots ####
# density plot
model_data %>%
ggplot(aes(norm_dist)) +
geom_density()
#### Modelling ####
#### Modelling: New idea ####
# raw norm_dist
m1 <- brm(norm_dist ~ norm_hoop_pos,
data = model_data,
family = "normal",
cores = 1,
chains = 1,
iter = 2000)
# plot posterior?
plt <- model_data %>%
add_predicted_draws(m1) %>%
ggplot(aes(.prediction)) +
geom_density() +
theme_minimal()
plt
# scaled_norm_dist
m2 <- brm(norm_dist2 ~ norm_hoop_pos,
data = model_data,
family = "beta",
cores = 1,
chains = 1,
iter = 2000)
plt <- model_data %>%
add_predicted_draws(m2) %>%
ggplot(aes(.prediction)) +
geom_density() +
theme_minimal()
plt
#### Modelling: Paper idea ####
load("scratch/df_part2_raw")
model_data_2 <- load("scratch/df_part2_raw")
model_data_2 <- dat %>%
filter(subject_position != 0)
head(model_data_2)
rm(dat)
model_data_2$stood_left <- 0
model_data_2$stood_left[model_data_2$subject_position < 0] <- 1
# small_hoop_left
model_data_2$small_hoop_left <- 0
model_data_2$small_hoop_left[model_data_2$small_pos < 0] <- 1
head(model_data_2)
m3 <- brm(stood_left ~ small_hoop_left,
data = model_data_2,
family = "bernoulli",
chains = 1,
cores = 1,
iter = 2000)
summary(m3)
plot(marginal_effects(m3))
model_data_2$small_hoop_left <- as.factor(model_data_2$small_hoop_left)
m3 <- brm(stood_left ~ small_hoop_left,
data = model_data_2,
family = "bernoulli",
chains = 1,
cores = 1,
iter = 2000)
plot(marginal_effects(m3))
plt <- model_data %>%
add_predicted_draws(m3) %>%
ggplot(aes(.prediction)) +
geom_density() +
theme_minimal()
plt
plt <- model_data %>%
add_predicted_draws(m3) %>%
ggplot(aes(.prediction, colour = small_hoop_left)) +
geom_density() +
theme_minimal()
plt
View(plt)
View(plt[["data"]])
plt <- model_data_2 %>%
add_predicted_draws(m3) %>%
ggplot(aes(.prediction, colour = small_hoop_left)) +
geom_density() +
theme_minimal()
plt
head(plt[["data"]])
plt <- model_data_2 %>%
add_predicted_draws(m3) %>%
group_by(.row, small_hoop_left) %>%
summarise(.prediction = mean(.prediction)) %>%
ggplot(aes(.prediction, colour = small_hoop_left)) +
geom_density() +
theme_minimal()
plt
plt <- model_data_2 %>%
add_predicted_draws(m3) %>%
group_by(.row, small_hoop_left) %>%
summarise(.prediction = mean(.prediction)) %>%
ggplot(aes(.prediction,
colour = small_hoop_left,
fill = small_hoop_left)) +
geom_density(alpha = 0.3) +
theme_minimal() +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
plt
plt$labels$colour <- "Small Hoop Left:"
plt$labels$fill <- "Small Hoop Left:"
plt
rm(list = ls ())
#### Do Some modelling of the Prob_match study ####
# Again, this is proportion data I guess so we should use beta dist?
# Use this on proportion to one side I guess?
# But we have the issue of there being three options
# ... Probably need to rescale it so 0 is left or right, and 0.5 is centre?
# then we can use more likely left vs. right?
# or just make it so 1 is most likely side in bias condition and left in the random one?
# Try using binomial data
# make predicted "fixated common" then use bias_type as a predictor
# can also included separation or close vs far to check things
#### Library ####
library(rstan)
library(tidyverse)
library(brms)
library(tidybayes)
#### Constants ####
# Gets Visual Degrees
get_VisDegs <- function(separation,distance){
((2*atan2(separation,(2*distance)))*180)/pi
}
#### Any constants ####
Screen_dist <- 54.4
ppcm <- 1920/54
#### load in data ####
load("scratch/new_data/df_part2")
#### Sort data ####
model_data <- df_part2 %>%
select(participant, bias, block, trial, separation, fixated_box, standard_boxes, bias_type) %>%
group_by(participant) %>%
mutate(Delta = separation/max(separation)) %>%
ungroup()
# add predictor column
model_data$fixated_likely <- 0
model_data$fixated_likely[model_data$standard_boxes == "most likely"] <- 1
#### Modelling ####
#### Modelling: Centre Vs. Side ####
setwd("E:/Github/Breaking_symmetry/Analyses/Experiment_4_Prob")
#### Do Some modelling of the Prob_match study ####
# Again, this is proportion data I guess so we should use beta dist?
# Use this on proportion to one side I guess?
# But we have the issue of there being three options
# ... Probably need to rescale it so 0 is left or right, and 0.5 is centre?
# then we can use more likely left vs. right?
# or just make it so 1 is most likely side in bias condition and left in the random one?
# Try using binomial data
# make predicted "fixated common" then use bias_type as a predictor
# can also included separation or close vs far to check things
#### Library ####
library(rstan)
library(tidyverse)
library(brms)
library(tidybayes)
#### Constants ####
# Gets Visual Degrees
get_VisDegs <- function(separation,distance){
((2*atan2(separation,(2*distance)))*180)/pi
}
#### Any constants ####
Screen_dist <- 54.4
ppcm <- 1920/54
#### load in data ####
load("scratch/new_data/df_part2")
#### Sort data ####
model_data <- df_part2 %>%
select(participant, bias, block, trial, separation, fixated_box, standard_boxes, bias_type) %>%
group_by(participant) %>%
mutate(Delta = separation/max(separation)) %>%
ungroup()
# add predictor column
model_data$fixated_likely <- 0
model_data$fixated_likely[model_data$standard_boxes == "most likely"] <- 1
#### Modelling ####
#### Modelling: Centre Vs. Side ####
head(model_data)
head(df_part2)
model_data$fixated_likely <- as.factor(model_data$fixated_likely)
# fixated centre
model_data$fixated_centre <- 0
model_data$fixated_centre[model_data$standard_boxes == "most likely"] <- 1
model_data$fixated_centre <- as.factor(model_data$fixated_centre)
head(model_data)
# fixated centre
model_data$fixated_centre <- 0
model_data$fixated_centre[model_data$standard_boxes == "centre"] <- 1
model_data$fixated_centre <- as.factor(model_data$fixated_centre)
head(model_data)
m1_centre_binom <- brm(fixated_centre ~ bias_type,
data = model_data,
family = "bernoulli",
cores = 1,
chains = 1,
iter = 2000)
summary(m1_centre_binom)
plot(marginal_effects(m1_centre_binom))
m2_centre_binom <- brm(fixated_centre ~ bias_type + Delta,
data = model_data,
family = "bernoulli",
cores = 1,
chains = 1,
iter = 2000)
plot(marginal_effects(m2_centre_binom))
m3_centre_binom <- brm(fixated_centre ~ (bias_type + Delta)^2,
data = model_data,
family = "bernoulli",
cores = 1,
chains = 1,
iter = 2000)
plot(marginal_effects(m3_centre_binom))
summary(m3_centre_binom)
plt <- model_data %>%
add_predicted_draws(m3_centre_binom) %>%
ggplot(aes(.prediction,
colour = bias_type,
fill = bias_type)) +
geom_density(alpha = 0.3) +
theme_minimal() +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
plt
plot(marginal_effects(m3_centre_binom))
range(model_data$Delta)
plt <- model_data %>%
add_predicted_draws(m3_centre_binom) %>%
group_by(.row, bias_type, Delta) %>%
summarise(.prediction = mean(.prediction)) %>%
ggplot(aes(.prediction,
colour = bias_type,
fill = bias_type)) +
geom_density(alpha = 0.3) +
theme_minimal() +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol()
plt
summary(m3_centre_binom)
plt <- model_data %>%
add_predicted_draws(m3_centre_binom) %>%
group_by(.row, bias_type, Delta) %>%
summarise(.prediction = mean(.prediction)) %>%
ggplot(aes(.prediction,
colour = Delta,
fill = Delta)) +
geom_density(alpha = 0.3) +
theme_minimal() +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol() +
facet_wrap(~bias_type)
plt
plt <- model_data %>%
add_predicted_draws(m3_centre_binom) %>%
group_by(.row, bias_type, Delta) %>%
filter(Delta == max(Delta) | Delta == min(Delta)) %>%
summarise(.prediction = mean(.prediction)) %>%
ungroup() %>%
mutate(Delta = as.factor(Delta)) %>%
ggplot(aes(.prediction,
colour = Delta,
fill = Delta)) +
geom_density(alpha = 0.3) +
theme_minimal() +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol() +
facet_wrap(~bias_type)
plt
plt <- model_data %>%
add_predicted_draws(m3_centre_binom) %>%
group_by(.row, bias_type, Delta) %>%
filter(Delta == max(Delta) | Delta == min(Delta))
plt <- model_data %>%
add_predicted_draws(m3_centre_binom) %>%
filter(Delta == max(Delta) | Delta == min(Delta)) %>%
group_by(.row, bias_type, Delta) %>%
summarise(.prediction = mean(.prediction)) %>%
ungroup() %>%
mutate(Delta = as.factor(Delta)) %>%
ggplot(aes(.prediction,
colour = Delta,
fill = Delta)) +
geom_density(alpha = 0.3) +
theme_minimal() +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol() +
facet_wrap(~bias_type)
plt
range(plt[["data"]]$Delta)
unique(plt[["data"]]$Delta)
plt <- model_data %>%
add_predicted_draws(m3_centre_binom) %>%
group_by(.row, bias_type, Delta) %>%
summarise(.prediction = mean(.prediction)) %>%
ungroup() %>%
filter(Delta == max(Delta) | Delta == min(Delta)) %>%
mutate(Delta = as.factor(Delta)) %>%
ggplot(aes(.prediction,
colour = Delta,
fill = Delta)) +
geom_density(alpha = 0.3) +
theme_minimal() +
ggthemes::scale_color_ptol() +
ggthemes::scale_fill_ptol() +
facet_wrap(~bias_type)
plt
