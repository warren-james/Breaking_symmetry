temp_avg_small$shift <- temp_avg_small$hoop_pos - temp_avg_small$small_hoop_dist
# remove small_hoop_dist
temp_avg_small <- temp_avg_small[,c("participant",
"hoop_pos",
"shift")]
# add this into norm_dat
norm_dat <- merge(temp_avg_small, norm_dat)
# reorder columns so it's clearer
norm_dat <- norm_dat[,c("participant",
"trial",
"colour",
"direction",
"subject_position",
"accuracy",
"R",
"Y",
"B",
"B_N_Size",
"Y_N_Size",
"R_N_Size",
"hoop_pos",
"small_pos",
"large_pos",
"norm_dist",
"switchSlab",
"shift")]
# tidy
rm(temp_avg, temp_avg_small, temp_small)
#### get standing position for equal accuracy ####
norm_dat$equacc <- norm_dist(norm_dat$shift, norm_dat$hoop_pos)
#### add in opt standing position ####
norm_dat$optpos <- norm_dat$equacc
norm_dat$optpos[norm_dat$hoop_pos > norm_dat$switchSlab] <- 1
# add in metres column
norm_dat$metres <- norm_dat$hoop_pos*Hoop_size
#### make plot of opt swithing poing by standing position ####
# still need to calculate their opt standing positions
temp_plt_dat <- norm_dat
temp_plt_dat$participant <- as.numeric(temp_plt_dat$participant)
plt <- ggplot(temp_plt_dat, aes(metres, norm_dist))
plt <- plt + geom_point(alpha = 0.3)
#plt <- plt + geom_jitter(width = 0.3, height = 0.0)
plt <- plt + theme_bw()
# plt <- plt + geom_line(aes(hoop_pos, equacc, colour = "Equal Accuracy"), size = 1.2, alpha = 0.7)
# plt <- plt + geom_line(aes(hoop_pos, optpos, colour = "Optimal"), size = 1.2, alpha = 0.7)
# plt <- plt + geom_point(aes(hoop_pos, optpos, colour = "Optimal"))
# plt <- plt + geom_point(aes(hoop_pos, equacc, colour = "Equal Accuracy"))
plt <- plt + geom_line(aes(metres, equacc,
colour = "Equal Accuracy"),
size = 1.2,
alpha = 0.7)
plt <- plt + geom_line(aes(metres, optpos,
colour = "Optimal"),
size = 1.2,
alpha = 0.7)
plt <- plt + geom_point(aes(metres, optpos,
colour = "Optimal"))
plt <- plt + geom_point(aes(metres, equacc,
colour = "Equal Accuracy"))
# plt <- plt + geom_vline(xintercept = norm_dat$switchSlab)
plt <- plt + scale_y_continuous(name="Normalised Participant Position", limits=c(-1,1))
plt <- plt + scale_x_continuous(name="Delta (Metres)" ,
limits= c(1.5, 10),
breaks = c(2,4,6,8,10))
plt <- plt + geom_hline(yintercept = 0)
plt <- plt + facet_wrap(~participant, ncol = 6)
plt <- plt + theme(legend.position = "bottom")
# Change legend title
plt$labels$colour <- "Line Type"
plt
#### save plot to figures folder ####
# ggsave("../../Figures/Experiment_3_Hoop_size/Session_2_plot.png",
#        width = 18,
#        height = 16,
#        units = "cm")
# tidy
rm(plt, temp_plt_dat)
#### proportion of standing positions ####
norm_dat$prop_sizes <- 0
norm_dat$prop_sizes[norm_dat$subject_position > 0] <- 1
norm_dat$prop_sizes[norm_dat$subject_position < 0] <- (-1)
# get summary of this for each participant and distance
# create df for this
prop_sides <- data.frame(participant = character(),
hoop_pos = numeric(),
prop_sizes = numeric(),
prop = numeric(),
count = numeric())
for(i in unique(norm_dat$participant)){
for(x in unique(norm_dat$hoop_pos[norm_dat$participant == i])){
for(z in unique(norm_dat$prop_sizes)){
temp_num <- (nrow(norm_dat[norm_dat$participant == i &
norm_dat$hoop_pos == x,]))
prop <- (nrow(norm_dat[norm_dat$participant == i &
norm_dat$hoop_pos == x &
norm_dat$prop_sizes == z,])/temp_num)
count <- nrow(norm_dat[norm_dat$participant == i &
norm_dat$hoop_pos == x &
norm_dat$prop_sizes == z,])
prop_sides <- rbind(prop_sides, data.frame(participant = i,
hoop_pos = x,
prop_sizes = z,
prop = prop,
count = count))
}
}
}
# tidy
rm(count, i, prop, temp_num, x, z)
prop_sides$prop_sizes <- as.factor(prop_sides$prop_sizes)
prop_sides$stpos_type <- "Centre"
prop_sides$stpos_type[prop_sides$prop_sizes == "-1"] <- "Large Hoop"
prop_sides$stpos_type[prop_sides$prop_sizes == "1"] <- "Small Hoop"
prop_sides$metres <- prop_sides$hoop_pos*Hoop_size
prop_sides$participant <- as.numeric(prop_sides$participant)
#### Make the proportion plot ####
prop_plt <- ggplot(data = prop_sides,
aes(x = metres,
y = prop))
prop_plt <- prop_plt + theme_bw()
prop_plt <- prop_plt + geom_area(aes(colour = stpos_type,
fill = stpos_type),
position = "stack")
prop_plt <- prop_plt + scale_y_continuous(name="Normalised Participant Position",
limits=c(0,1))
prop_plt <- prop_plt + scale_x_continuous(name="Delta (Metres)",
limits= c(1.5, 10),
breaks = c(2,4,6,8,10))
prop_plt <- prop_plt + theme(legend.position = "bottom")
# prop_plt <- prop_plt + scale_fill_discrete(breaks = c("Large Hoop",
#                                                       "Centre",
#                                                       "Small Hoop"))
# prop_plt <- prop_plt + scale_color_discrete(breaks = c("Large Hoop",
#                                                        "Centre",
#                                                        "Small Hoop"))
#prop_plt <- prop_plt + geom_vline(data = switch_points,
#                                  aes(xintercept = as.numeric(switch_point)),
#                                  linetype = "dashed")
prop_plt <- prop_plt + facet_wrap(~participant, ncol = 6)
prop_plt$labels$colour <- "Stood Towards"
prop_plt$labels$fill <- "Stood Towards"
# Draw plot
prop_plt
# Save plot
# ggsave("../../Figures/Experiment_3_Hoop_size/Session_2_proportions.png",
#        width = 18,
#        height = 16,
#        units = "cm")
#### get t-test results to look at proportions ####
# sort out the data frame for this
bias_sides <- prop_sides[prop_sides$stpos_type != "Centre",]
bias_sides_2 <- bias_sides %>%
group_by(participant, stpos_type) %>%
summarise(total = sum(count)) %>%
mutate(prop = total/sum(total))
# now do some tests I think...
t.test(prop ~ stpos_type, data = bias_sides_2)
# shows it significant
# but this is a bad way to do it and you know that....
#### GLMER time bois and girls ####
# setup the data
glm_dat <- dat[dat$subject_position != 0,]
# now get if they were closer to the small hoop or not
glm_dat$small_hoop_left <- 0
glm_dat$small_hoop_left[glm_dat$small_pos < 0] <- 1
glm_dat$subj_left <- 0
glm_dat$subj_left[glm_dat$subject_position < 0] <- 1
# sort out factors
glm_dat$small_hoop_left <- as.factor(glm_dat$small_hoop_left)
m1 <- glmer(subj_left ~ small_hoop_left + (1|participant),
family = binomial(),
data = glm_dat)
# tidy
rm(prop_plt)
# # get summaries of counts for each participant to check against level 3's
# temp <- group_by(prop_sides, participant, prop_sizes)
# compare_dat <- summarise(temp, count = sum(count))
#
# # tidy
# rm(temp)
# # so it was my mistake in the 'input small hoop pos' part
#### Accuracy: Get accuarcy for each participant in each strategy ####
# separate acc_slab files
small_acc_slab <- acc_slab[acc_slab$hoop_size == "small",]
large_acc_slab <- acc_slab[acc_slab$hoop_size == "large",]
# remove hoop_size from both as we know what they are, makes merging easier
small_acc_slab <- select(small_acc_slab,
participant,
slab,
acc)
large_acc_slab <- select(large_acc_slab,
participant,
slab,
acc)
# reduce number of columns because we don't need them all
reduced_norm_dat <- select(norm_dat,
participant,
subject_position,
shift,
accuracy,
hoop_pos,
small_pos,
large_pos)
# sort out participant
# will need to normalise distances again, but we don't need that for now
# tidy
rm(acc_slab)
# want to subtract standing pos from distance to get the distance from each hoop
# then get absolute value obvs
#### Centre (distance) ####
# sort out acc_slab dataframes so they match up
cssm <- small_acc_slab
# rename acc column
colnames(cssm) <- c("participant",
"hoop_pos",
"csm_acc")
# large
csla <- large_acc_slab
# rename columns
colnames(csla) <- c("participant",
"hoop_pos",
"cla_acc")
# merge these?
temp <- merge(csla, cssm)
# add into norm_dat
reduced_norm_dat <- merge(reduced_norm_dat, temp)
# tidy
rm(temp, large_acc_slab, small_acc_slab)
# get average accuracy of this strategy
reduced_norm_dat$cavg_acc <- (reduced_norm_dat$cla_acc + reduced_norm_dat$csm_acc)/2
#### Expected Accuracy ####
# need to work out distances for each hoop
reduced_norm_dat$small_dist <- abs(reduced_norm_dat$small_pos - reduced_norm_dat$subject_position)
reduced_norm_dat$large_dist <- abs(reduced_norm_dat$large_pos - reduced_norm_dat$subject_position)
# use csla and cssm data again
exla <- csla
exsm <- cssm
# tidy
rm(csla,cssm)
# rename columns
colnames(exla) <- c("participant",
"large_dist",
"exla_acc")
colnames(exsm) <- c("participant",
"small_dist",
"exsm_acc")
# merge with main dataset
reduced_norm_dat <- merge(reduced_norm_dat, exsm)
reduced_norm_dat <- merge(reduced_norm_dat, exla)
# get avg accuracy from this now
reduced_norm_dat$exavg_acc <- (reduced_norm_dat$exla_acc + reduced_norm_dat$exsm_acc)/2
#### Centre (equal accuracy) ####
# get centre for equal accuracy distances
reduced_norm_dat$small_dist_eq <- (reduced_norm_dat$small_pos - reduced_norm_dat$shift)
reduced_norm_dat$large_dist_eq <- abs(reduced_norm_dat$large_pos - reduced_norm_dat$shift)
# use exla and exsm data again
eqla <- exla
eqsm <- exsm
# tidy
rm(exla,exsm)
# rename columns
colnames(eqla) <- c("participant",
"large_dist_eq",
"eqla_acc")
colnames(eqsm) <- c("participant",
"small_dist_eq",
"eqsm_acc")
# merge with main dataset
reduced_norm_dat <- merge(reduced_norm_dat, eqsm)
reduced_norm_dat <- merge(reduced_norm_dat, eqla)
# get avg accuracy from this now
reduced_norm_dat$eqavg_acc <- (reduced_norm_dat$eqla_acc + reduced_norm_dat$eqsm_acc)/2
#### Optimal Accuracy ####
# make opt standing pos
reduced_norm_dat$opt_pos <- reduced_norm_dat$shift
reduced_norm_dat$opt_pos[reduced_norm_dat$eqavg_acc < 0.5] <- reduced_norm_dat$hoop_pos[reduced_norm_dat$eqavg_acc < 0.5]
# get distance from small and large hoops
reduced_norm_dat$small_dist_opt <- (reduced_norm_dat$hoop_pos - reduced_norm_dat$opt_pos)
reduced_norm_dat$large_dist_opt <- abs(reduced_norm_dat$large_pos - reduced_norm_dat$opt_pos)
# get accuracy for large and small hoop
# can reuse eqla and eqsm for this part
opla <- eqla
opsm <- eqsm
# tidy
rm(eqla, eqsm)
# rename columns
colnames(opla) <- c("participant",
"large_dist_opt",
"opla_acc")
colnames(opsm) <- c("participant",
"small_dist_opt",
"opsm_acc")
# merge with reduce_norm_dat
reduced_norm_dat <- merge(reduced_norm_dat, opla)
reduced_norm_dat <- merge(reduced_norm_dat, opsm)
# tidy
rm(opla, opsm)
# get avg acc
reduced_norm_dat$opt_avg <- (reduced_norm_dat$opla_acc + reduced_norm_dat$opsm_acc)/2
#### new data set with only need columns ####
Acc_dat <- select(reduced_norm_dat,
participant,
accuracy,
hoop_pos,
cavg_acc,
exavg_acc,
eqavg_acc,
opt_avg)
# get averages
Acc_dat_wide <- Acc_dat %>%
group_by(participant, hoop_pos) %>%
summarise(Optimal = mean(opt_avg),
#Actual = mean(accuracy),
"Centre (Distance)" = mean(cavg_acc),
Expected = mean(exavg_acc),
"Centre (Probability)" = mean(eqavg_acc))
# make suitable for plotting (long in this case)
plt_data <- gather(Acc_dat_wide, Acc_type, Accuracy, Optimal:"Centre (Probability)", factor_key = T)
#### Plot of Accuracy types ####
plt <- ggplot(plt_data, aes(hoop_pos*Hoop_size, Accuracy, colour = Acc_type))
plt <- plt + geom_point()
plt <- plt + geom_line()
plt <- plt + facet_wrap(~participant, ncol = 6)
plt <- plt + theme(legend.position = "bottom")
plt$labels$x <- "Delta (metres)"
plt$labels$colour <- "Line Type"
plt
# ggsave("../../Figures/Experiment_3_Hoop_size/Session_2_plot_Accuracy.png",
#        width = 20,
#        height = 13,
#        units = "cm")
# tidy
rm(plt)
#### plot Accuracy types with regions instead ####
# setup dataframes
plt_dat_Optimal <- plt_data[plt_data$Acc_type == "Optimal",]
plt_dat_Centre <- plt_data[plt_data$Acc_type == "Centre (Distance)",]
# make plot
plt <- ggplot(plt_data, aes(hoop_pos*Hoop_size,
Accuracy))
plt <- plt + theme_bw()
plt <- plt + geom_area(data = plt_dat_Optimal, aes(hoop_pos*Hoop_size,
Accuracy),
fill = "blue",
alpha = 0.3)
plt <- plt + geom_area(data = plt_dat_Centre, aes(hoop_pos*Hoop_size,
Accuracy),
fill = "red",
alpha = 0.3)
plt <- plt + geom_line(data = plt_data[plt_data$Acc_type == "Expected" |
plt_data$Acc_type == "Centre (Probability)",],
aes(linetype = Acc_type),
size = 1)
plt <- plt + theme(legend.position = "bottom")
# plt <- plt + geom_point()
# plt <- plt + geom_line(aes(linetype = condition))
plt <- plt + facet_wrap(~as.numeric(participant), ncol = 6)
plt$labels$x <- "Delta (Metres)"
plt$labels$y <- "Accuracy"
plt$labels$linetype <- "Accuracy for:"
plt
ggsave("../../Figures/Experiment_3_Hoop_size/Accuracyshaded_regions.png",
height = 12,
width = 18,
units = "cm")
(21+25+29+22+20+21+19+23+23+27)/10
sd(21+25+29+22+20+21+19+23+23+27)
sd(c(21,25,29,22,20,21,19,23,23,27)
)
setwd("F:/Uni/PhD/1st year/9-Month Report/Analyses/Experiment_2_Two_throw")
rm(list = ls())
library(tidyverse)
library(psyphy)
library(reshape2)
#### Any Functions ####
#### Notes #####
#### Any constants ####
Hoop_size <- 0.46
#### Load data ####
load("scratch/df_part2_OT")
load("scratch/df_part2_TT")
#### sort data ####
# Add grouping variable
df_part2_OT$Num_throws <- "One-Throw"
df_part2_TT$Num_throws <- "Two-Throws"
# select columns to keep
OT <- select(df_part2_OT,
Participant,
Num_throws,
Trial.no.,
Position,
HoopDelta,
abspos,
switchSlab)
TT <- select(df_part2_TT,
Participant,
Num_throws,
Trial.no.,
Position,
HoopDelta,
abspos,
switchSlab)
# combine
df <- rbind(OT,TT)
# save data
df_part2 <- df
save(df_part2, file = "scratch/df_part2")
# tidy
rm(df_part2_OT, df_part2_TT, OT, TT, df_part2)
#### PLOTS ####
#### PLOTS: Individual points for all positions ####
plt <- ggplot(df, aes(HoopDelta*Hoop_size,
abspos,
colour = Num_throws))
plt <- plt + geom_point(position = "jitter")
plt <- plt + facet_wrap(~as.numeric(Participant), nrow = 3)
plt <- plt + theme_bw()
plt <- plt + geom_vline(aes(xintercept = switchSlab*Hoop_size),
linetype = "dashed")
plt <- plt + scale_y_continuous(name = "Normalised Participant standing position",
limits = c(0,2))
plt <- plt + scale_x_continuous(name = "Delta (Metres)",
limits = c(0,10),
breaks = c(2,4,6,8,10))
plt <- plt + theme(legend.position = "bottom")
plt$labels$colour <- "Number of Throws"
# show plot
plt
# save this
# ggsave("../../Figures/Experiment_2_Two_throw/Part2_BOTH_AvG_allpoints.png",
#        height = 12,
#        width = 18,
#        units = "cm")
#### PLOTS: Average standing position ####
# setup dataframe
pltdat <- as.tibble(df)
pltdat <- pltdat %>%
group_by(Participant, HoopDelta, Num_throws, switchSlab) %>%
summarise(mean_pos = mean(abspos))
# make plot
plt <- ggplot(pltdat, aes(HoopDelta*Hoop_size,
mean_pos,
colour = Num_throws))
plt <- plt + geom_point(position = position_jitter(width=.1,height=.0))
plt <- plt + facet_wrap(~Participant, nrow = 3)
plt <- plt + theme_bw()
plt <- plt + geom_vline(aes(xintercept = switchSlab * Hoop_size))
plt <- plt + scale_y_continuous(name = "Normalised participant standing position",
limits = c(0,1))
plt <- plt + scale_x_continuous(name = "Delta (Metres)",
limits = c(0,10),
breaks = c(2,4,6,8,10))
plt$labels$colour <- "No. of Throws"
# show plot
plt
head(df)
m1 <- glmer(abs(Position) ~ Num_throws + (1|Participant),
data = glm_dat)
library(tidyverse)
library(psyphy)
library(reshape2)
m1 <- glmer(abs(Position) ~ Num_throws + (1|Participant),
data = glm_dat)
library(lme4)
m1 <- glmer(abs(Position) ~ Num_throws + (1|Participant),
data = glm_dat)
m1 <- glmer(abs(Position) ~ Num_throws + (1|Participant),
data = df)
summary(m1)
range(df$Position)
glm_dat <- df
glm_dat$Position <- abs(glm_dat$Position)
m1 <- glmer(Position ~ Num_throws + (1|Participant),
data = glm_dat)
summary(m1)
head(pltdat)
head(df)
head(glm_dat)
m1 <- glmer(abspos ~ Num_throws + (1|Participant),
data = glm_dat)
summary(m1)
m1 <- glmer(abspos ~ Num_throws + (1|Participant),
family = guassian(),
data = glm_dat)
m1 <- glmer(abspos ~ Num_throws + (1|Participant),
family = gaussian(),
data = glm_dat)
summary(m1)
m1 <- glmer(abspos ~ Num_throws + (1|Participant),
family = binomial(),
data = glm_dat)
range(glm_dat$abspos)
m1 <- glmer(abspos ~ Num_throws + (1|Participant),
family = gaussian(),
data = glm_dat)
library(lmertest)
install.packages("lmerTest")
library(lmerTest)
m1 <- glmer(abspos ~ Num_throws + (1|Participant),
family = gaussian(),
data = glm_dat)
summary(m1)
version()
R
m1 <- glmer(abspos ~ Num_throws,
family = gaussian(),
data = glm_dat)
rm(list = ls())
c <- c(1,4,5,3)
c
as.numeric(c)
as.numeric(as.factor(c))
