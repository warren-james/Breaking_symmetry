# choices for everyone
num_subs <- 20
choices <- c(round(rnorm(num_subs/2, Fifty$position, 2)), round(rnorm(num_subs/2, 4, 2)))
demo_version <- tibble(Person = seq(1,num_subs,1),
Group = rep(c("Achievement", "Accuracy"), each = num_subs/2),
Distance = choices)
# add in expected accuracy
demo <- merge(demo_version, acc_seps_overall)
# plot
plt_avg +
geom_segment(data = demo,
aes(x = Distance, y = 0,
xend = Distance, yend = Accuracy,
colour = Group),
linetype = 1,
size = 1.2,
alpha = 1) +
geom_segment(data = demo,
aes(x = 0, y = Accuracy,
xend = Distance, yend = Accuracy,
colour = Group),
linetype = 1,
size = 1.2,
alpha = 1) +
see::scale_color_flat()
demo %>%
ggplot(aes(Distance, colour = Group, fill = Group)) +
geom_histogram(binwidth = 1, position = "dodge")+
see::scale_color_flat() +
see::scale_fill_flat() +
theme_bw()
demo %>%
ggplot(aes(Distance, colour = Group, fill = Group)) +
geom_density(alpha = .3) +
see::scale_color_flat() +
see::scale_fill_flat() +
theme_bw()
#### ENTER IN CHOICES FOR EVERYONE ####
# num_subs <- 20
choices <- c(P1, P2, P3, 1, 20,
7, 8, 7, 20, 15,
14, 20, 8, 6, 1,
13, 13, 1, 12, 24)
num_subs <- length(choices)
df_choices_overall <- tibble(Person = seq(1,num_subs,1),
Group = rep(c("Achievement", "Accuracy"), num_subs/2),
Distance = choices)
# add in expected accuracy
df_choices_overall <- merge(df_choices_overall, acc_seps_overall)
plt_avg1 <- plt_avg +
geom_segment(data = df_choices_overall,
aes(x = Distance, y = 0,
xend = Distance, yend = Accuracy,
colour = Group),
linetype = 1) +
geom_segment(data = df_choices_overall,
aes(x = 0, y = Accuracy,
xend = Distance, yend = Accuracy,
colour = Group),
linetype = 1) +
see::scale_color_flat()
plt_avg1
plt_avg2 <- df_choices_overall %>%
ggplot(aes(Distance, colour = Group, fill = Group)) +
# geom_density(alpha = 0.3) +
geom_histogram(position = "dodge") +
see::scale_color_flat() +
see::scale_fill_flat() +
theme_bw()
plt_avg2
head(plt_avg[["data"]])
head(plt_avg2[["data"]])
head(df_choices_overall)
df_choices_overall %>% group_by(Group) %>% summarise(mu = mean(Distance))
df_choices_overall %>% group_by(Group) %>% summarise(mu = mean(Distance), sig = sd(Distance))
t.test(df_choices_overall$Distance ~ df_choices_overall$Group)
View(df_choices_overall)
tibble(participants = c(seq(97,94,1)))
temp <- tibble(participants = c(seq(97,94,1)))
####
# we want order to change...
# And that's it?
# so we just need to to do every other participant
library(tidyverse)
temp <- tibble(participants = c(seq(97,94,1)))
temp
(seq(97,94,1)
)
seq(1, 2, 0.5)
seq(1, -1, 0.5)
seq(97,94,-1)
library(tidyverse)
temp <- tibble(participants = c(seq(97,94,-1), seq(1,30,1)))
temp
View(temp)
library(tidyverse)
temp <- tibble(participants = c(seq(97,94,-1), seq(1,30,1)),
order = rep(c(1,2), length(participants)/2))
head(temp)
View(temp)
741e6
Eu_old <- 3300
Eu_present <- 741e6
# time
time_taken <- 42000
x <- seq(1,6,1)
y <- dnorm(x, mean = 3, 2)
plot(x, y )
x <- seq(1,6,1)
y <- dnorm(x, mean = 3.5, 2)
plot(x, y )
#simple sim
pairs <- Eu_old/2
going <- T
start_val <- Eu_old
count <- 1
while(going){
pairs <- start_val/2
start_val <- start_val + (pairs * 3)
count <- count + 1
if(start_val > Eu_present){
print(count)
}
}
pairs <- Eu_old/2
going <- T
start_val <- Eu_old
count <- 1
while(going){
pairs <- start_val/2
start_val <- start_val + (pairs * 3)
count <- count + 1
if(start_val > Eu_present){
print(count)
going = F
}
}
2^.25
2*(2*.25)
2^.25
4*sqrt(2^1)
help(nthroot)
??nthroot
log(4)
2^1.386
log2(4)
exp(1.386)
60*.65
60*.65
40*.65
60*.6
setwd("F:/Uni/Github/Breaking_symmetry/Analyses/Experiment_3_Hoop_size")
#### Modelling and plotting Hoop Size ####
#### Library ####
library(brms)
library(rstan)
library(tidybayes)
library(tidyverse)
#### Constants ####
Hoop_size <- 0.46
#### Functions ####
# This function squashes the range of values so as to be used in a beta regression
squash <- function(y, max, min, squash){
y <- y * ((max-squash) - (min + squash)) + (min + squash)
}
# get draws
draw_post <- function(model, data){
close <- min(data$norm_hoop_pos)
mid <- median(data$norm_hoop_pos)
far <- max(data$norm_hoop_pos)
draws_df <- model %>%
spread_draws(b_Intercept,
b_norm_hoop_pos) %>%
mutate(hoop_Close = b_Intercept + close * b_norm_hoop_pos,
hoop_Mid = b_Intercept + mid * b_norm_hoop_pos,
hoop_Far = b_Intercept + far * b_norm_hoop_pos) %>%
select(.iteration,
hoop_Close,
hoop_Mid,
hoop_Far) %>%
gather(c(hoop_Close:hoop_Far),
key = "parameter",
value = "estimate") %>%
separate(parameter,
into = c("remove", "Distance Type")) %>%
select(-remove)
# estimates
plt_estimates <- draws_df %>%
mutate(prop = boot::inv.logit(estimate)) %>%
ggplot(aes(prop,
colour = `Distance Type`,
fill = `Distance Type`)) +
geom_density(alpha = .3) +
see::scale_color_flat() +
see::scale_fill_flat() +
scale_x_continuous("Normalised Delta") +
theme_bw()
# amount above .5
prop_above.5 <- draws_df %>%
mutate(above0_5 = ifelse(boot::inv.logit(estimate) > .5, 1, 0)) %>%
summarise(above0_5 = mean(above0_5))
# get hdi
draws_hdi <- draws_df %>%
group_by(`Distance Type`) %>%
mutate(prop = boot::inv.logit(estimate)) %>%
summarise(lower = hdi(prop)[,1],
mean = mean(prop),
upper = hdi(prop)[,2],
med = median(prop))
output <- list(draws_df,
plt_estimates,
prop_above.5,
draws_hdi)
names(output) <- c("draws_df",
"plt_estimates",
"Prop_above.5",
"draws_HDI")
return(output)
}
#### Load in data ####
load("scratch/df_part2_norm")
# sort out data for modelling?
model_data <- norm_dat %>%
select(participant, hoop_pos, norm_dist) %>%
group_by(participant) %>%
mutate(norm_hoop_pos = hoop_pos/max(hoop_pos)) %>%
ungroup() %>%
filter(norm_dist >= -1, norm_dist <= 1) %>%
mutate(norm_dist2 = (norm_dist + 1)/2,
norm_dist2 = squash(norm_dist2, 1, 0, 1e-4))
# Should we model this as a beta dist and make centre <- 0.5?
#### Quick Plots ####
# density plot
model_data %>%
ggplot(aes(norm_dist)) +
geom_density() +
geom_histogram(aes(y = ..density..))
#### Modelling ####
#### Modelling: New idea ####
# normalised dist  sp > .5 =close to small, sp < .5 close to big
m1 <- brm(norm_dist2 ~ norm_hoop_pos + (norm_hoop_pos|participant),
data = model_data,
family = "beta",
prior = c(set_prior("student_t(3,0,3)", class = "b")),
cores = 1,
chains = 1,
iter = 2000,
warmup = 1000)
draws <- draw_post(m1, model_data)
draws$plt_estimates
draws$draws_HDI
#### Modelling and plotting Hoop Size ####
#### Library ####
library(brms)
library(rstan)
library(tidybayes)
library(tidyverse)
#### Constants ####
Hoop_size <- 0.46
#### Functions ####
# This function squashes the range of values so as to be used in a beta regression
squash <- function(y, max, min, squash){
y <- y * ((max-squash) - (min + squash)) + (min + squash)
}
# get draws
draw_post <- function(model, data){
close <- min(data$norm_hoop_pos)
mid <- median(data$norm_hoop_pos)
far <- max(data$norm_hoop_pos)
draws_df <- model %>%
spread_draws(b_Intercept,
b_norm_hoop_pos) %>%
mutate(hoop_Close = b_Intercept + close * b_norm_hoop_pos,
hoop_Mid = b_Intercept + mid * b_norm_hoop_pos,
hoop_Far = b_Intercept + far * b_norm_hoop_pos) %>%
select(.iteration,
hoop_Close,
hoop_Mid,
hoop_Far) %>%
gather(c(hoop_Close:hoop_Far),
key = "parameter",
value = "estimate") %>%
separate(parameter,
into = c("remove", "Distance Type")) %>%
select(-remove)
# estimates
plt_estimates <- draws_df %>%
mutate(prop = boot::inv.logit(estimate)) %>%
ggplot(aes(prop,
colour = `Distance Type`,
fill = `Distance Type`)) +
geom_density(alpha = .3) +
see::scale_color_flat() +
see::scale_fill_flat() +
scale_x_continuous("Normalised Delta") +
theme_bw()
# amount above .5
prop_above.5 <- draws_df %>%
mutate(above0_5 = ifelse(boot::inv.logit(estimate) > .5, 1, 0)) %>%
summarise(above0_5 = mean(above0_5))
# get hdi
draws_hdi <- draws_df %>%
group_by(`Distance Type`) %>%
mutate(prop = boot::inv.logit(estimate)) %>%
summarise(lower = hdi(prop)[,1],
mean = mean(prop),
upper = hdi(prop)[,2],
med = median(prop))
# overall hdi
draws_hdi_overall <- draws_df %>%
mutate(prop = boot::inv.logit(estimate)) %>%
summarise(lower = hdi(prop)[,1],
mean = mean(prop),
upper = hdi(prop)[,2],
med = median(prop))
Hdi_pos <- list(draws_hdi,
draws_hdi_overall)
output <- list(draws_df,
plt_estimates,
prop_above.5,
Hdi_pos)
names(output) <- c("draws_df",
"plt_estimates",
"Prop_above.5",
"draws_HDI")
return(output)
}
draws <- draw_post(m1, model_data)
draws$draws_HDI[1]
draws$draws_HDI[2]
rm(list= ls())
setwd("F:/Uni/Github/Breaking_symmetry/Analyses/Experiment_2_Two_throw")
#### Modelling of the Two Hoops data ####
# Using the Bayes approach now
#### Library ####
library(tidybayes)
library(tidyverse)
library(brms)
library(rstan)
#### Constants ####
#### Functions ####
# This function squashes the range of values so as to be used in a beta regression
squash <- function(y, max, min, squash){
y <- y * ((max-squash) - (min + squash)) + (min + squash)
}
# get draws
draw_post <- function(model, data){
close <- min(data$norm_delta)
mid <- median(data$norm_delta)
far <- max(data$norm_delta)
draws_df <- model %>%
spread_draws(b_Intercept,
b_norm_delta,
b_Num_throwsTwoMThrows,
`b_norm_delta:Num_throwsTwoMThrows`) %>%
mutate(One_throw = b_Intercept,
Norm_delta_OT = b_norm_delta,
Two_throw = b_Num_throwsTwoMThrows,
Norm_delta_TT = `b_norm_delta:Num_throwsTwoMThrows`) %>%
select(-b_Intercept,
-b_norm_delta,
-b_Num_throwsTwoMThrows,
-`b_norm_delta:Num_throwsTwoMThrows`) %>%
mutate(hoop_Close.One_throw = One_throw + (close * Norm_delta_OT),
hoop_Mid.One_throw = One_throw + (mid * Norm_delta_OT),
hoop_Far.One_throw = One_throw + (far * Norm_delta_OT),
hoop_Close.Two_throw = One_throw + Two_throw + (close * Norm_delta_TT),
hoop_Mid.Two_throw = One_throw + Two_throw + (mid * Norm_delta_TT),
hoop_Far.Two_throw = One_throw + Two_throw + (far * Norm_delta_TT)) %>%
select(.iteration,
hoop_Close.One_throw,
hoop_Mid.One_throw,
hoop_Far.One_throw,
hoop_Close.Two_throw,
hoop_Mid.Two_throw,
hoop_Far.Two_throw) %>%
gather(c(hoop_Close.One_throw:hoop_Far.Two_throw),
key = "parameter",
value = "estimate") %>%
separate(parameter,
into= c("Dist_type", "Num_throws"),
sep = "\\.") %>%
separate(Dist_type,
into = c("remove", "Dist_type"),
sep = "_") %>%
select(-remove)
# mean_vals
mu_vals <- draws_df %>%
group_by(Dist_type, Num_throws) %>%
summarise(mu = mean(estimate),
med = median(estimate)) %>%
mutate(mu = boot::inv.logit(mu),
med = boot::inv.logit(med))
# estimates
plt_estimates <- draws_df %>%
mutate(prop = boot::inv.logit(estimate)) %>%
ggplot(aes(prop,
colour = Num_throws,
fill = Num_throws)) +
geom_density(alpha = .3) +
see::scale_color_flat() +
see::scale_fill_flat() +
scale_x_continuous("Normalised Delta") +
theme_bw() +
coord_cartesian(expand = 0) +
geom_vline(data = mu_vals,
aes(xintercept = mu,
colour = Num_throws),
linetype = "dashed") +
facet_wrap(~Dist_type)
# get diff
# overall
diff_overall <- draws_df %>%
group_by(.iteration, Num_throws) %>%
summarise(estimate = boot::inv.logit(mean(estimate))) %>%
spread(Num_throws, estimate) %>%
ungroup() %>%
mutate(diff = One_throw - Two_throw)
above0_overall <- diff_overall %>%
mutate(above0 = ifelse(diff > 0,1,0)) %>%
summarise(above0 = mean(above0))
plt_diff_over <- diff_overall %>%
ggplot(aes(diff)) +
geom_density(colour = "blue",
fill = "blue",
alpha = .3)
# by dist_type
diff_dist_type <- draws_df %>%
mutate(estimate = boot::inv.logit(estimate)) %>%
spread(Num_throws, estimate) %>%
ungroup() %>%
mutate(diff = One_throw - Two_throw)
plt_diff_dist <- diff_dist_type %>%
ggplot(aes(diff,
colour = Dist_type,
fill = Dist_type)) +
geom_density(alpha = .3)
above0_dist <- diff_dist_type %>%
group_by(Dist_type) %>%
mutate(above0 = ifelse(diff > 0,1,0)) %>%
summarise(above0 = mean(above0))
# get hdi of diff
# overall
draws_hdi_overall <- draws_df %>%
group_by(Num_throws) %>%
mutate(prop = boot::inv.logit(estimate)) %>%
summarise(lower = hdi(prop)[,1],
mean = mean(prop),
upper = hdi(prop)[,2],
med = median(prop))
draws_hdi_diff_overall <- diff_overall %>%
summarise(lower = hdi(diff)[,1],
mean = mean(diff),
upper = hdi(diff)[,2])
# dist_type
draws_hdi_dist <- draws_df %>%
group_by(Num_throws, Dist_type) %>%
mutate(prop = boot::inv.logit(estimate)) %>%
summarise(lower = hdi(prop)[,1],
mean = mean(prop),
upper = hdi(prop)[,2],
med = median(prop))
draws_hdi_diff_dist <- diff_dist_type %>%
group_by(Dist_type) %>%
summarise(lower = hdi(diff)[,1],
mean = mean(diff),
upper = hdi(diff)[,2])
plts <- list(plt_estimates,
plt_diff_over,
plt_diff_dist)
hdis <- list(draws_hdi_overall,
draws_hdi_diff_overall,
draws_hdi_dist,
draws_hdi_diff_dist)
above0 <- list(above0_overall,
above0_dist)
output <- list(draws_df,
plts,
hdis,
above0)
names(output) <- c("Draws_df",
"Plots",
"HDIs",
"Above_0")
return(output)
}
#### Load in data ####
load("scratch/df_part2")
#### sort data ####
model_data_pos <- df_part2 %>%
group_by(Participant) %>%
mutate(norm_delta = HoopDelta/max(HoopDelta)) %>%
ungroup() %>%
filter(abspos <= 1) %>%
mutate(abspos = squash(abspos, 1, 0, 1e-4))
m1_pos <- brm(abspos ~ norm_delta * Num_throws + (norm_delta * Num_throws|Participant),
family = "beta",
data = model_data_pos,
prior = c(set_prior("student_t(3,0,3)", class = "b")),
cores = 1,
chains = 1,
iter = 2000,
warmup = 1000)
draws <- draw_post(m1_pos, model_data_pos)
draws$Plots[1]
draws$HDIs[1]
draws$HDIs[2]
draws$HDIs[3]
draws$HDIs[1]
draws$HDIs[3]
draws$Above_0
rm(list = ls())
