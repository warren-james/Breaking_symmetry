# loop through
for(ii in 1:n_choices){
# set doors
round_doors <- sample(doors, 3, replace = F)
door_orig <- readline(prompt = "Please choose a door: 1, 2, or 3
")
}
3
3
#### Monty Hall simulation ####
# need to simulate a series of decisions and when switching is good
#### library ####
library(tidyverse)
#### Functions ####
# make the host
# the host should find the 0's and select one of those doors
host <- function(doors, participant_choice){
# find doors
available <- as.numeric(which(doors == 0))
if(participant_choice %in% available){
# print("True")
picked <- available[available != participant_choice]
} else {
picked <- sample(available, 1)
}
return(picked)
}
#### Parameters ####
n_doors <- 3
n_success <- 1
n_choices <- 10
# make list
doors <- c(rep(1, n_success), rep(0, n_doors - n_success))
#### Run the exp ####
df_monty <- tibble(iter = numeric(),
door_orig = numeric(),
door_second = numeric(),
success = numeric())
# loop through
for(ii in 1:n_choices){
# set doors
round_doors <- sample(doors, 3, replace = F)
door_orig <- readline(prompt = "Please choose a door (1, 2, or 3):  ")
}
3
host_pick = 1
door_orig = 3
round_doors <- sample(doors, 3, replace = F)
remaining_door <- round_doors[-door_orig, host_pick]
remaining_door <- round_doors[-door_orig, -host_pick]
remaining_door <- round_doors[-door_orig]
picked_doors <- c(host_pick, door_orig)
# which door remains
remaining_door <- door_idx[!door_idx %in% picked_doors]
door_idx <- c(1,2,3)
picked_doors <- c(host_pick, door_orig)
# which door remains
remaining_door <- door_idx[!door_idx %in% picked_doors]
#### Monty Hall simulation ####
# need to simulate a series of decisions and when switching is good
#### library ####
library(tidyverse)
#### Functions ####
# make the host
# the host should find the 0's and select one of those doors
host <- function(doors, participant_choice){
# find doors
available <- as.numeric(which(doors == 0))
if(participant_choice %in% available){
# print("True")
picked <- available[available != participant_choice]
} else {
picked <- sample(available, 1)
}
return(picked)
}
#### Parameters ####
n_doors <- 3
n_success <- 1
n_choices <- 10
# make list
doors <- c(rep(1, n_success), rep(0, n_doors - n_success))
#### Run the exp ####
df_monty <- tibble(iter = numeric(),
door_orig = numeric(),
door_second = numeric(),
success = numeric())
# loop through
for(ii in 1:n_choices){
# set doors
round_doors <- sample(doors, 3, replace = F)
door_idx <- c(1,2,3)
door_orig <- readline(prompt = "Please choose a door (1, 2, or 3):  ")
# host picks a door
host_pick <- host(round_doors, door_orig)
# picked doors
picked_doors <- c(host_pick, door_orig)
# which door remains
remaining_door <- door_idx[!door_idx %in% picked_doors]
print(paste("The host opens door ", host_pick, " revealing a ", round_doors[host_pick], ".", sep = ""))
change <- readline(prompt = "Would you like to change? (y or n):  ")
if(change == "y"){
door_second <- remaining_door
} else {
door_second <- door_orig
}
print(paste("You picked door ", door_second, ". Behind that door was ", round_doors[door_second]))
if(round_doors[door_second] == 1){
print("You win a point")
} else {
print{"You don't win anything"}
}
}
#### Monty Hall simulation ####
# need to simulate a series of decisions and when switching is good
#### library ####
library(tidyverse)
#### Functions ####
# make the host
# the host should find the 0's and select one of those doors
host <- function(doors, participant_choice){
# find doors
available <- as.numeric(which(doors == 0))
if(participant_choice %in% available){
# print("True")
picked <- available[available != participant_choice]
} else {
picked <- sample(available, 1)
}
return(picked)
}
#### Parameters ####
n_doors <- 3
n_success <- 1
n_choices <- 10
# make list
doors <- c(rep(1, n_success), rep(0, n_doors - n_success))
#### Run the exp ####
df_monty <- tibble(iter = numeric(),
door_orig = numeric(),
door_second = numeric(),
success = numeric())
# loop through
for(ii in 1:n_choices){
# set doors
round_doors <- sample(doors, 3, replace = F)
door_idx <- c(1,2,3)
door_orig <- readline(prompt = "Please choose a door (1, 2, or 3):  ")
# host picks a door
host_pick <- host(round_doors, door_orig)
# picked doors
picked_doors <- c(host_pick, door_orig)
# which door remains
remaining_door <- door_idx[!door_idx %in% picked_doors]
print(paste("The host opens door ", host_pick, " revealing a ", round_doors[host_pick], ".", sep = ""))
change <- readline(prompt = "Would you like to change? (y or n):  ")
if(change == "y"){
door_second <- remaining_door
} else {
door_second <- door_orig
}
print(paste("You picked door ", door_second, ". Behind that door was ", round_doors[door_second]))
if(round_doors[door_second] == 1){
print("You win a point")
} else {
print("You don't win anything")
}
}
head(df_monty)
#### Monty Hall simulation ####
# need to simulate a series of decisions and when switching is good
#### library ####
library(tidyverse)
#### Functions ####
# make the host
# the host should find the 0's and select one of those doors
host <- function(doors, participant_choice){
# find doors
available <- as.numeric(which(doors == 0))
if(participant_choice %in% available){
# print("True")
picked <- available[available != participant_choice]
} else {
picked <- sample(available, 1)
}
return(picked)
}
#### Parameters ####
n_doors <- 3
n_success <- 1
n_choices <- 10
# make list
doors <- c(rep(1, n_success), rep(0, n_doors - n_success))
#### Run the exp ####
df_monty <- tibble(iter = numeric(),
door_orig = numeric(),
door_second = numeric(),
success = numeric())
# loop through
for(ii in 1:n_choices){
# set doors
round_doors <- sample(doors, 3, replace = F)
door_idx <- c(1,2,3)
door_orig <- readline(prompt = "Please choose a door (1, 2, or 3):  ")
# host picks a door
host_pick <- host(round_doors, door_orig)
# picked doors
picked_doors <- c(host_pick, door_orig)
# which door remains
remaining_door <- door_idx[!door_idx %in% picked_doors]
print(paste("The host opens door ", host_pick, " revealing a ", round_doors[host_pick], ".", sep = ""))
change <- readline(prompt = "Would you like to change? (y or n):  ")
if(change == "y"){
door_second <- remaining_door
} else {
door_second <- door_orig
}
print(paste("You picked door ", door_second, ". Behind that door was ", round_doors[door_second]))
if(round_doors[door_second] == 1){
print("You win a point")
success <- 1
} else {
print("You don't win anything")
success <- 0
}
df_monty <- rbind(df_monty, tibble(iter = ii,
door_orig = door_orig,
door_second = door_second,
success = success))
}
head(df_monty)
df_monty %>%
mutate(switch = ifelse(door_orig == door_second, 0, 1)) %>%
group_by(switch) %>%
summarise(mean_success = mean(success))
door_idx <- seq(1, length(doors), 1)
door_orig <- readline(prompt = "Please choose a door (", door_dix, "):  ")
door_orig <- readline(prompt = paste("Please choose a door (", door_dix, "):  ", sep = ""))
door_orig <- readline(prompt = paste("Please choose a door (", door_idx, "):  ", sep = ""))
door_idx <- seq(1, length(doors), 1)
door_idx
door_orig <- readline(prompt = paste("Please choose a door (", door_idx, "):  ", sep = ""))
#### Monty Hall simulation ####
# need to simulate a series of decisions and when switching is good
#### library ####
library(tidyverse)
#### Functions ####
# make the host
# the host should find the 0's and select one of those doors
host <- function(doors, participant_choice){
# find doors
available <- as.numeric(which(doors == 0))
if(participant_choice %in% available){
# print("True")
picked <- available[available != participant_choice]
} else {
picked <- sample(available, 1)
}
return(picked)
}
# make the gameshow
gameshow <- function(n_choices, doors, df){
for(ii in 1:n_choices){
# set doors
round_doors <- sample(doors, length(doors), replace = F)
door_idx <- seq(1, length(doors), 1)
door_orig <- readline(prompt = "Please choose a door (1, 2, or 3):  ")
# host picks a door
host_pick <- host(round_doors, door_orig)
# picked doors
picked_doors <- c(host_pick, door_orig)
# which door remains
remaining_door <- door_idx[!door_idx %in% picked_doors]
print(paste("The host opens door ", host_pick, " revealing a ", round_doors[host_pick], ".", sep = ""))
change <- readline(prompt = "Would you like to change? (y or n):  ")
if(change == "y"){
door_second <- remaining_door
} else {
door_second <- door_orig
}
print(paste("You picked door ", door_second, ". Behind that door was ", round_doors[door_second]))
if(round_doors[door_second] == 1){
print("You win a point")
success <- 1
} else {
print("You don't win anything")
success <- 0
}
df <- rbind(df, tibble(iter = ii,
door_orig = door_orig,
door_second = door_second,
success = success))
}
return(df)
}
#### Parameters ####
n_doors <- 3
n_success <- 1
n_choices <- 10
# make list
doors <- c(rep(1, n_success), rep(0, n_doors - n_success))
#### Run the exp ####
df_monty <- tibble(iter = numeric(),
door_orig = numeric(),
door_second = numeric(),
success = numeric())
df_monty <- gameshow(n_choices, doors, df_monty)
df_monty %>%
mutate(switch = ifelse(door_orig == door_second, 0, 1)) %>%
group_by(switch) %>%
summarise(mean_success = mean(success))
rm(list = ls())
setwd("F:/Uni/Github/Breaking_symmetry/Analyses/Experiment_5_Unequal_Reward")
#### Make figures ####
# These are the figures for the unequal reward study
#### Library ####
library(tidyverse)
#### load in data ####
load("scratch/data/model_data")
#### Pre-processing #####
# sort the labels for their standing positions so we have some consitencies
model_data <- model_data %>%
group_by(Participant) %>%
mutate(slab_measures = as.numeric(as.factor(Norm_Delta)),
slab_measures = factor(slab_measures,
labels = c("90%", "75%", "25%", "10%")))
#### Make plots ####
# density plot
model_data %>%
ggplot(aes(Norm_Dist,
colour = Gamble_Type,
fill = Gamble_Type)) +
geom_density(alpha = .3) +
# geom_histogram(aes(y = ..density..),
#                position = "dodge") +
see::scale_color_flat() +
see::scale_fill_flat() +
facet_wrap(~dist_type)
model_data %>%
ggplot(aes(slab_measures,
Norm_Dist,
colour = Gamble_Type,
fill = Gamble_Type)) +
geom_boxplot(alpha = .3) +
scale_x_discrete("Slab Measures") +
scale_y_continuous(breaks = c(0,1),
labels = c("Centre", "Side")) +
see::scale_color_flat() +
see::scale_fill_flat() +
theme_bw() +
theme(axis.title.y = element_blank()) +
labs(colour = "Split Type",
fill = "Split Type")
head(model_data)
model_data %>%
ggplot(aes(Norm_Dist,
colour = Gamble_Type,
fill = Gamble_Type)) +
geom_histogram(alpha = .3,
position = "dodge")
model_data %>%
ggplot(aes(Norm_Dist,
colour = Gamble_Type,
fill = Gamble_Type)) +
geom_histogram(alpha = .3,
position = "dodge") +
facet_wrap(~slab_measures)
# remake this but as a histogram
model_data %>%
ggplot(aes(Norm_Dist,
colour = Gamble_Type,
fill = Gamble_Type)) +
geom_histogram(alpha = .3,
position = "dodge") +
facet_wrap(~slab_measures) +
theme_bw() +
see::scale_color_flat() +
see::scale_fill_flat()
# remake this but as a histogram
model_data %>%
ggplot(aes(Norm_Dist,
colour = Gamble_Type,
fill = Gamble_Type)) +
geom_histogram(alpha = .3,
position = "dodge") +
facet_wrap(~Dist_Type) +
theme_bw() +
see::scale_color_flat() +
see::scale_fill_flat()
# remake this but as a histogram
model_data %>%
ggplot(aes(Norm_Dist,
colour = Gamble_Type,
fill = Gamble_Type)) +
geom_histogram(alpha = .3,
position = "dodge") +
facet_wrap(~dist_type) +
theme_bw() +
see::scale_color_flat() +
see::scale_fill_flat()
model_data %>%
group_by(Participant) %>%
summarise(unequal_prop = mean(Unequal)) %>%
ggplot(aes(unequal_prop)) +
geom_histogram(aes(y = ..density..)) +
geom_density()
dev.off()
head(model_data)
library(brms)
range(model_data$Norm_Dist)
m1 <- brm(Norm_Dist ~ (Norm_Delta + Unequal)^2 + (1 + Norm_Delta + Unequal|participant),
data = model_data,
family = "beta",
chains = 1,
iter = 2000,
warmup = 1000)
m1 <- brm(Norm_Dist ~ (Norm_Delta + Unequal)^2 + (1 + Norm_Delta + Unequal|Participant),
data = model_data,
family = "beta",
chains = 1,
iter = 2000,
warmup = 1000)
summary(m1)
plot(marginal_effects(m1))
head(model_data)
m1 <- brm(Norm_Dist ~ (Norm_Delta + Gamble_Type)^2 + (1 + Norm_Delta + Gamble_Type|Participant),
data = model_data,
family = "beta",
chains = 1,
iter = 2000,
warmup = 1000)
summary(m1)
plot(marginal_effects(m1))
model_data <- model_data %>%
mutate(un_prop = mean(Unequal))
head(model_data)
m1 <- brm(Norm_Dist ~ (Norm_Delta + un_prop)^2 + (1 + Norm_Delta + un_prop|Participant),
data = model_data,
family = "beta",
chains = 1,
iter = 2000,
warmup = 1000)
summary(m1)
plot(marginal_effects(m1))
dev.off()
#### Moving truck ####
# packages
library(tidyverse)
# some constants
# screen x res
x_res <- 1920
# first make sigmoid function
delta <- seq(1, x_res/2, 1)
a <- (15/max(delta))*-1
c <- max(delta)/2
success_rate <- 1/(1+exp(-a*(delta-c)))
plot(delta, success_rate, type = "l")
# tidy
rm(a,c, delta)
# make list of deltas
delta_list = seq(100, x_res/2, 100)
rm(list = ls())
travel_time <- 100
betas <- data.frame(skew = c("rand_uniform", "hard_cutoff", "broad"),
beta1 = c(1,10000, 10),
beta2 = c(1,10000, 10))
beta_frame <- data.frame(skew = character(),
Delta = numeric(),
estimate = numeric())
# make same loop as above
for(skew in unique(betas$skew)){
# temp frame
temp <- betas[betas$skew == skew,]
# sim
y <- (round(rbeta(1000000, temp$beta1, temp$beta2)*8)+1)*travel_time
# data frame
delta_frame <- data.frame(skew = skew,
Delta = seq(100,900,100))
delta_frame <- delta_frame %>%
group_by(skew, Delta) %>%
mutate(estimate = sum(y >= Delta)/length(y))
# bind to frame
beta_frame <- rbind(beta_frame, as.data.frame(delta_frame))
}
rm(betas, skew, y, temp)
# now make plot
plt <- beta_frame %>%
ggplot(aes(Delta, estimate, colour = skew)) +
geom_point() +
stat_smooth(method = glm,
method.args = list(family = "binomial"),
aes(y = estimate),
se = F) +
scale_x_continuous(breaks = seq(100,900,100)) +
scale_colour_ptol()
plt$labels$x = "Delta (Pixels)"
plt$labels$y = "Estimated success rate"
plt$labels$colour = "Shape"
plt
plt <- beta_frame %>%
ggplot(aes(Delta, estimate, colour = skew)) +
geom_point() +
stat_smooth(method = glm,
method.args = list(family = "binomial"),
aes(y = estimate),
se = F) +
scale_x_continuous(breaks = seq(100,900,100)) +
see::scale_color_flat()
plt$labels$x = "Delta (Pixels)"
plt$labels$y = "Estimated success rate"
plt$labels$colour = "Shape"
plt
